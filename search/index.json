[{"content":"","date":"2023-11-27T00:00:00Z","image":"https://rickyhsieh.github.io/p/better-late-than-never/opening-cover_hu7f2775a2b16efa071764c77b345eaa12_192566_120x120_fill_q75_box_smart1.jpg","permalink":"https://rickyhsieh.github.io/p/better-late-than-never/","title":"Better late than never !"},{"content":"2024 Jan LC challenge 題目 459. Repeated Substring Pattern 方法 序列 abcabc 很明顯，是由可以由abc組成，兩個abc前半後半都相同， 所以將abcabc + abcabc ，勢必會在中間再找到一個 abcabc。 但這兩個相加的字串，需要去頭去尾，否則沒有意義(如果開頭沒擋或結尾沒有擋，無法匹配到中間的)。\nMy code 方法一 1 2 3 4 5 6 7 class Solution { public boolean repeatedSubstringPattern(String s) { String s2 = s + s; s2 = s2.substring(1, s2.length() - 1); return s2.contains(s); } } 方法二 KMP解法 ","date":"2024-01-18T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-459.-repeated-substring-pattern/","title":"Daily Leetcode - 459. Repeated Substring Pattern"},{"content":"2024 Jan LC challenge 題目 380. Insert Delete GetRandom O(1) 方法 Implement the RandomizedSet class:\nRandomizedSet() Initializes the RandomizedSet object.\nbool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.\nbool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.\nint getRandom() Returns a random element from the current set of elements (it\u0026rsquo;s guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.\nMy Code 方法一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.util.*; public class RandomizedSet { private Map\u0026lt;Integer, Integer\u0026gt; map; // 將值映射到其在數組中的索引 private List\u0026lt;Integer\u0026gt; list; // 存儲元素 private Random rand; // 用於生成隨機數 public RandomizedSet() { map = new HashMap\u0026lt;\u0026gt;(); list = new ArrayList\u0026lt;\u0026gt;(); rand = new Random(); } public boolean insert(int val) { if (map.containsKey(val)) { return false; // 元素已存在 } map.put(val, list.size()); list.add(val); return true; } public boolean remove(int val) { if (!map.containsKey(val)) { return false; // 元素不存在 } int index = map.get(val); int lastElement = list.get(list.size() - 1); list.set(index, lastElement); // 與最後一個元素交換 map.put(lastElement, index); // 更新交換元素的索引 list.remove(list.size() - 1); // 移除最後一個元素 map.remove(val); // 從映射中移除 return true; } public int getRandom() { return list.get(rand.nextInt(list.size())); } } 問題 Q1 map.put(val, list.size());為何 ? 目的在於將新加入List的元素，將它的index，記錄在HashMap中，HashMap儲存該值以及其所引。 當我們添加一個新元素時會加在List尾巴，所以list.size()的由來就是這樣。 如此一來我們添加新元素進list時保持O(1)。\nQ2 remove 方法在O(1) ? 關鍵在於，要刪除點與最後一個元素交換，可以把時間保持O(1)；\n1 2 list.set(index, lastElement); // 與最後一個元素交換 map.put(lastElement, index); // 更新交換元素的索引 因為我們在List、Array刪除元素時，假設是在中間刪除，那它後面的元素都要往前挪動，造成時間複雜度為O(n)。\n而直接跟最後一個數交換，頂多O(1)。\n再來更新map元素索引，因為最後一個元素被移動到了一個新的位置（即原來要刪除的元素的位置）。 因此，需要在 map 中更新這個元素的索引。\nmap 中儲存了每個元素及其在 list 中的索引。 由於 lastElement 的位置已經改變，其索引也必須相應更新。\n方法二 Dynamic array，動態Array擴容策略\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class RandomizedSet { private final Random random = new Random(); private final Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); private int[] vals = new int[32]; private int i = 0; public RandomizedSet() { } public boolean insert(int val) { Integer added = map.putIfAbsent(val, i); if (added != null) return false; if (i \u0026gt;= vals.length) { vals = Arrays.copyOf(vals, vals.length * 2); } vals[i++] = val; return true; } public boolean remove(int val) { //從 map 中移除元素 val，如果該元素存在，則傳回其在數組 vals 中的索引。 Integer removed = map.remove(val); if (removed == null) return false; //不存在 if (removed \u0026lt; i - 1) { vals[removed] = vals[i-1]; map.put(vals[i-1], removed); } i--; return true; } public int getRandom() { int index = random.nextInt(i); return vals[index]; } } /** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet obj = new RandomizedSet(); * boolean param_1 = obj.insert(val); * boolean param_2 = obj.remove(val); * int param_3 = obj.getRandom(); */ map.putIfAbsent(key, value) :\n如果它不存在則放置，如果存在返回該已存在key的value。 在這裡的解釋為 : 如果 val 已經存在，putIfAbsent 方法將傳回已存在元素的索引，否則傳回 null。\nif (added != null) return false;: 如果 val 已經存在於雜湊表中，方法傳回 false。 if (i \u0026gt;= vals.length) { vals = Arrays.copyOf(vals, vals.length * 2); }:\n如果陣列 vals 沒有足夠空間儲存新元素，則將其容量擴大兩倍。 vals[i++] = val;: 將新元素儲存在陣列 vals 中，並增加索引 i。 傳回 true 表示插入成功。\nremove 如果被移除的元素不是陣列中的最後一個元素，則將最後一個元素移至被移除元素的位置，並更新雜湊表中該元素的索引。 i\u0026ndash;;: 減少數組 vals 中的元素計數。\n","date":"2024-01-16T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-380.-insert-delete-getrandom-o1/","title":"Daily Leetcode - 380. Insert Delete GetRandom O(1)"},{"content":"2024 Jan LC challenge 題目 2870. Minimum Number of Operations to Make Array Empty 相似題目 : 2244. Minimum Rounds to Complete All Tasks\n方法 My Code 方法一 freq % 3 == 1 直接傳回 -1，因為無法僅透過刪除兩個或三個相同元素的操作來處理只出現一次的元素。\nfreq % 3 == 0 這表示可以只透過刪除三個相同元素的操作來處理這個數字。 操作次數是 value / 3。\nfreq % 3 == 2 || freq % 3 == 1 這表示除了可以透過刪除三個相同元素的操作處理的部分外，還需要額外一次操作來處理剩餘的一個或兩個元素。 因此，總操作次數是 (value / 3) + 1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int minOperations(int[] nums) { Map\u0026lt;Integer, Integer\u0026gt; freq = new HashMap\u0026lt;\u0026gt;(); for(int num : nums) { freq.put(num, freq.getOrDefault(num, 0) + 1); } int count = 0; for (Integer value : freq.values()) { if (value == 1) { return -1; } if (value % 3 == 0 ) { count += value / 3; }else if (value % 3 == 1 || value % 3 == 2){ count += (value / 3) + 1; }else { return -1; } } return count; } } 方法二 freq 表示陣列中某個特定元素的出現次數。 目的是要透過盡可能少的操作次數使數組中的這些元素被完全刪除，每次操作可以刪除兩個或三個具有相同值的元素。\nfreq % 3 == 0： 這表示元素的出現次數是3的倍數。 在這種情況下，可以僅透過刪除三個相同元素的操作來處理這些元素。 操作的次數是 freq / 3，即元素總數除以3。\nfreq % 3 == 2： 這意味著元素的出現次數比3的倍數多2。 例如，如果一個元素出現了5次（5 % 3 == 2），你不能只透過刪除三個相同元素的操作來處理所有元素。 首先，你可以刪除 (freq - 2) 個元素（即3個），然後再用一次操作刪除剩下的2個元素。 所以，操作次數是 (freq - 2) / 3 + 1。\nfreq % 3 == 1： 這意味著元素的出現次數比3的倍數多1。 需要透過一些操作來處理這些元素。 首先，你刪除 (freq - 4) 個元素（即3的倍數），然後用兩次操作分別刪除剩下的4個元素（一次刪除兩個，另一次刪除兩個）。 所以，操作次數是 (freq - 4) / 3 + 2。\n1 2 3 4 5 6 7 8 // 其餘略 if (freq % 3 == 0) ans += freq / 3; else if (freq % 3 == 2) ans += (freq - 2) / 3 + 1; else if (freq % 3 == 1) ans += (freq - 4) / 3 + 2; 2244 題 一個數學向上取整技巧 題目可以用上面那一題去解，雖然題意不太一樣。 這邊主講向上取整 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int minimumRounds(int[] tasks) { Map\u0026lt;Integer, Integer\u0026gt; freq = new HashMap\u0026lt;\u0026gt;(); for (int i : tasks) { freq.put(i, freq.getOrDefault( i, 0) + 1); } int count = 0; for(int key: freq.keySet()) { int val = freq.get(key); if(val==1) return -1; count += (val+2)/3; } return count; } } 關於這一行 為何要加二 1 count += (val+2)/3; 因為本題是Greedy，計算所需要的最小次數。 那加2是啥意思 ? 加了不會影響結果 ?\n舉例來說 :\n今天 val = 6 : 6 / 3 = 2, 如果 (6 + 2) / 3 = 2 , 其實就沒有變化，效果是一樣的（因為整數除法會捨去小數部分）。\n但今天如果是 val = 7 : 7 / 3 = 2 代表我們只操作兩次， 但這至少三次才能吃下他，所以 (7 + 2) / 3 = 3，至少三次。\n這種加2的方法在整數除法中是一種有效的技巧，用於確保在計算所需操作次數時能夠向上取整， 反映完成所有任務所需的最小操作次數 。\n","date":"2024-01-04T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-2870.-minimum-number-of-operations-to-make-array-empty/","title":"Daily Leetcode - 2870. Minimum Number of Operations to Make Array Empty"},{"content":"2024 Jan LC challenge 題目 2610. Convert an Array Into a 2D Array With Conditions 將一個1D陣列，轉換成 2D 陣列，並滿足以下條件。\nThe 2D array should contain only the elements of the array nums. Each row in the 2D array contains distinct integers. The number of rows in the 2D array should be minimal. 方法 計算1D陣列，元素出現次數 找出最大出現次數，這個就代表我需要有多少Rows 建造一個新2D array 遍歷原數組，塞入新陣列中(要先判斷是否重複) My Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public boolean isHappy(int n) { int slow = n; int fast = getNext(n); do { slow = getNext(slow); fast = getNext(getNext(fast)); } while(fast != 1 \u0026amp;\u0026amp; fast != slow); return fast == 1; } private int getNext(int number) { int totalSum = 0; while (number \u0026gt; 0) { int d = number % 10; number = number / 10; totalSum += d * d; } return totalSum; } } ","date":"2024-01-02T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-2610.-convert-an-array-into-a-2d-array-with-conditions/","title":"Daily Leetcode - 2610. Convert an Array Into a 2D Array With Conditions"},{"content":"2023 Dec LC challenge 題目 141. Linked List Cycle 確認有環 找入口 確認有環 使用快慢指標，一個快指標、一個慢指標，就想像成跑步相對速度一個跑得快，一個跑得慢，總會相遇。\n找到入口 帶把隨想錄\nMy Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while(fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if(fast == slow) { ListNode index1 = fast; ListNode index2 = head; while(index1 != index2) { index1 = index1.next; index2 = index2.next; } return index1; } } return null; } } 說明 ","date":"2023-12-27T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-141.-linked-list-cycle/","title":"Daily Leetcode - 141. Linked List Cycle"},{"content":"2023 Dec LC challenge 題目 1578. Minimum Time to Make Rope Colorful 選擇保留移除時間最長的氣球的原因是為了最小化總的移除時間。 這個選擇是基於以下邏輯：\n目標是減少連續的同色氣球：為了讓氣球繩多彩，需要確保沒有兩個連續的氣球是同一色。 代表在一串連續的同色氣球中，我們至少需要移除一個氣球。\n最小化移除時間：我們的目標是在達到上述條件的同時，使總的移除時間盡可能小。\n決定保留哪個氣球：在一組連續的同色氣球中，如果我們選擇移除那個需要最長時間來移除的氣球，那麼我們實際上是在選擇最不經濟的選項。 換句話說，移除其他任何一個氣球的成本都會比移除這個最耗時的氣球小。\n保留最耗時的氣球：因此，最優策略是保留那個需要最長時間來移除的氣球，並移除其他所有同色氣球。 這樣，我們移除氣球的總時間就是這組同色氣球中所有移除時間之和減去最長的那個移除時間。\nMy Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int minCost(String colors, int[] neededTime) { int left = 0; int right = 0; int totalTime = 0; char[] c = colors.toCharArray(); while(right \u0026lt; c.length) { int currentGroupTime = 0; // 當前兩個重複顏色要移除的時間總和 int maxTimeInGroup = 0; // 兩個重複顏色移除時間的最大值 while(right \u0026lt; c.length \u0026amp;\u0026amp; c[right] == c[left]) { currentGroupTime += neededTime[right]; maxTimeInGroup = Math.max(neededTime[right], maxTimeInGroup); right++; } totalTime += currentGroupTime - maxTimeInGroup; // 總和 - - 最大值 = 最小那個 left = right; } return totalTime; } } 說明 內部循環是如何運作的： 初始狀態：一開始，left 和 right 都指向第一個字元 \u0026lsquo;a\u0026rsquo;（索引 0）。 此時，currentGroupTime 和 maxTimeInGroup 都初始化為 0。\n內部循環的開始： 進入內部循環時，right 指向索引 0（第一個 \u0026lsquo;a\u0026rsquo;）。 因為 c[right]（即 \u0026lsquo;a\u0026rsquo;）和 c[left]（同樣是 \u0026lsquo;a\u0026rsquo;）是相同的，所以循環繼續。 currentGroupTime 更新為 neededTime[0]，即 time1。 maxTimeInGroup 更新為 neededTime[0] 和 maxTimeInGroup 中的較大值，這時就是 time1。 然後 right 自增，現在指向索引 1（第二個 \u0026lsquo;a\u0026rsquo;）。 內部循環的第二次迭代：\n此時，right 指向第二個 \u0026lsquo;a\u0026rsquo;，並且因為它仍與 left 指向的 \u0026lsquo;a\u0026rsquo; 相同，循環繼續。 currentGroupTime 現在加上 neededTime[1]，即 time1 + time2。 maxTimeInGroup 更新為 neededTime[1] 和目前 maxTimeInGroup 中的較大值，即 max(time1, time2)。 right 再次自增，現在超出了字串的範圍，循環結束。\n內部循環結束： 此時，我們已經處理了一組連續的同色氣球\u0026rsquo;aa\u0026rsquo;，併計算出了它們的總移除時間currentGroupTime（time1 + time2）和這組中最大的單一移除時間maxTimeInGroup（max(time1, time2 )）。 在外部循環中，我們計算 totalTime 為 currentGroupTime - maxTimeInGroup，即 (time1 + time2) - max(time1, time2)。 這代表了除了最難移除的氣球以外其他氣球的移除時間。 透過這個過程，currentGroupTime 成功地累積了一組連續同色氣球的總移除時間，而 maxTimeInGroup 則確保我們只保留了這組中移除成本最高的氣球。\n","date":"2023-12-27T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-1578.-minimum-time-to-make-rope-colorful/","title":"Daily Leetcode - 1578. Minimum Time to Make Rope Colorful"},{"content":"2023 Dec LC challenge 題目 202. Happy Number My Code trick: 不快樂數 : 4 -\u0026gt; 16 -\u0026gt; 37 -\u0026gt; 258 \u0026gt; 85 -\u0026gt; 145 -\u0026gt; 42 -\u0026gt; 20 -\u0026gt; 4 會進入一個循環。\n快慢指標解 快慢指標如果有解最終會指向 1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public boolean isHappy(int n) { int slow = n; int fast = getNext(n); do { slow = getNext(slow); fast = getNext(getNext(fast)); } while(fast != 1 \u0026amp;\u0026amp; fast != slow); return fast == 1; } private int getNext(int number) { int totalSum = 0; while (number \u0026gt; 0) { int d = number % 10; number = number / 10; totalSum += d * d; } return totalSum; } } 慢指標（Slow Pointer）：這個指標每次移動一步。 在這個上下文中，\u0026ldquo;一步\u0026rdquo; 意味著對當前數字執行平方和的運算。 例如，如果慢指標目前指向數字 19，那麼它下一步會指向82。\n快指標（Fast Pointer）：這個指標每次移動兩步驟。 他執行兩次平方和的運算。 繼續上面的例子，如果快指標目前指向 19，那麼它的下一步是先移動到 82，然後再根據 82 的平方和進行下一步移動。 所以，如果 82 的平方和是68，那麼快指針將會移動到 68。\n偵測循環或到達 1：如果數字是快樂數，這個過程最終會讓數字變成 1。 這意味著快指針或慢指針（或兩者）會最終到達 1。 如果數字不是快樂數，那麼快指標和慢指標最終會在某個數字上相遇，這意味著它們進入了一個循環，而這個循環中不包含 1。\n終止條件：這個方法的終止條件是快指針到達 1（意味著找到了一個快樂數），或者快慢指針相遇（意味著不是快樂數，因為它們陷入了循環）。\n這種快慢指針是一種有效的檢測循環存在的方法。\nHashSet 解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean isHappy(int n) { Set\u0026lt;Integer\u0026gt; nums = new HashSet\u0026lt;\u0026gt;(); while (n != 1) { int temp = 0; while(n != 0) { int digit = n % 10; //位數 temp += digit * digit; n = n / 10; } if(!nums.add(temp)) { return false; } n = temp; } return true; } } ","date":"2023-12-27T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-202.-happy-number/","title":"Daily Leetcode - 202. Happy Number"},{"content":"LinkedList in Java Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ListNode { int val; // 節點值 ListNode next; // 指向下一個 public ListNode() { // 節點 contructor } public ListNode(int val) { // 節點 contructor this.val = val; } public ListNode(int val, ListNode next) { // 節點 contructor this.val = val; this.next = next; } } 說明 成員變數：\nint val;：這是結點儲存的數據，通常是整數型別。 ListNode next;：這是指向鍊錶中下一個結點的參考。\n無參構造函數 public ListNode()：\n這個建構函式建立一個沒有資料和下一個節點引用的空結點。\n帶有一個參數的建構子 public ListNode(int val)：\n這個建構函式建立一個包含特定值 val 的結點，但沒有指定下一個節點，即 next 預設為 null。\n有兩個參數的建構子 public ListNode(int val, ListNode next)：\n這個建構函式建立一個包含特定值 val 的結點，並指定其下一個節點為 next。 這個 ListNode 類別是建立單鍊錶的基礎。 使用它來建立LL，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class LinkedListDemo { public static void main(String[] args) { ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(3); node1.next = node2; node2.next = node3; ListNode current = node1; while (current != null) { System.out.print(current.val + \u0026#34; -\u0026gt; \u0026#34;); current = current.next; } System.out.println(\u0026#34;null\u0026#34;); } } ","date":"2023-12-27T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/linkedlist-%E5%AF%A6%E4%BD%9C/","title":"LinkedList 實作"},{"content":"2023 Dec LC challenge 題目 1155.Number of Dice Rolls With Target Sum 這個問題是一個典型的動態規劃問題，其中涉及到計算給定數量的骰子（n 個），每個骰子有k 個面（編號為1 到k），擲出它們時面朝上的數字之和 等於一個特定目標值（target）的可能方式的數量。\n要解決這個問題，我們可以使用動態規劃的方法。 這種方法涉及建立一個二維數組（或等價的資料結構），其中每個元素代表達到特定和的方式的數量。 我們可以逐步建立這個數組，直到達到目標和。\n問題解釋 輸入：\nn：骰子的數量。 k：每個骰子的面數。 target：我們要達到的目標和。 輸出：\n傳回達到目標和 target 的不同方式的數量。 動態規劃邏輯：\n建立一個二維數組 dp，其中 dp[i][j] 表示用 i 個骰子組成和為 j 的不同方式的數量。 初始化 dp[0][0] = 1，因為用 0 個骰子組成和為 0 的方式只有一種，就是什麼都不做。 遍歷每個骰子（1 到 n），對於每個骰子，更新和的可能性。 對於每個可能的和（1 到 target），考慮所有可能的骰子麵值（1 到 k）。 對於每個骰子面值，更新 dp[i][j]。 如果目前和 j 大於或等於骰麵值，那麼 dp[i][j] += dp[i-1][j - 骰麵值]。 模運算：\n由於答案可能非常大，所以需要對結果進行模運算（10^9 + 7）。 演算法範例 假設 n = 2（2 個骰子），k = 6（每個骰子有 6 個面），target = 7（目標和為 7）。 我們需要計算使用這兩個骰子組成和為 7 的不同方式的數量。\nMy Code 這題目的，用於計算達到目標和的不同方式數量。它接收三個參數：n（骰子的數量），k（每個骰子的面數），和 target（目標和）。\n1 2 public class Solution { public int numRollsToTarget(int n, int k, int target) { 我們定義一個數組，\n1 long[][] dp = new long[n+1][target+1]; 定義一個2D數組 dp，其中 dp[i][j] 表示用 i 個骰子得到總和為 j 的方式數量。使用 long 類型是為了防止在計算過程中出現整數溢出。\n1 dp[0][0] = 1 初始化 dp[0][0] 為 1，意味著没有骰子（i = 0）且目標和為 0（j = 0）的情况只有一種可能，即不擲任何骰子。\n1 for(int i = 1; i \u0026lt; n + 1; i++){ 最外層循環，遍歷每一面骰子。\n1 for(int j = 1; j \u0026lt; target + 1; j++){ 遍歷 1 到 target 所有可能總和。\n1 2 long sum = 0; for(int x = 1; x \u0026lt; k+1; x++){ 對於每个 i 和 j 的組合，初始化一个 sum 來累加所有可能達到總和 j 的方式數量。内部的循环遍歷所有可能的骰子面值\n1 if(j-x \u0026gt;= 0){sum += dp[i-1][j-x];} 如果當前總和 j 減去骰子面值 x 不小於 0，則將 dp[i-1][j-x] 的值累加到 sum 中。這代表了使用前 i-1 個骰子達到總和 j-x 的所有方式。\n1 2 } dp[i][j] = sum % 1000000007; 將累加得到的 sum 對 1000000007 取模後，賦值给 dp[i][j]。這一步是為了防止整數溢出，並滿足題目要求的模運算。\n1 2 3 4 5 } } return (int)(dp[n][target] % 1000000007); } } 返回使用 n 個骰子達到總和 target 的方式數量，對結果再次進行模運算以確保答案的正確性。\n這個方法透過動態規劃計算了使用 n 個骰子達到特定總和的所有可能方式的數量。 它逐步建立起 dp 數組，每個元素都基於前面的計算結果。 這種方法有效地利用了重疊子問題的特性，是解決此類計數問題的經典方法。\nfull code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int numRollsToTarget(int n, int k, int target) { long[][] dp = new long[n+1][target+1]; dp[0][0] = 1; for(int i = 1; i \u0026lt; n + 1; i++){ for(int j = 1; j \u0026lt; target + 1; j++){ long sum = 0; for(int x = 1; x \u0026lt; k+1; x++){ if(j-x \u0026gt;= 0){sum += dp[i-1][j-x];} } dp[i][j] = sum % 1000000007; } } return (int)(dp[n][target] % 1000000007); } } // dp[i][j] = using i dices, number of ways to satisfy j // dp[i][j] = dp[i-1][j-x] for x from 1 to k ","date":"2023-12-26T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-1155.number-of-dice-rolls-with-target-sum/","title":"Daily Leetcode - 1155.Number of Dice Rolls With Target Sum"},{"content":"2023 Dec LC challenge 題目 54. Spiral Matrix 代碼隨想錄-螺旋矩陣 賈考博-leetcode 54 螺旋矩陣 : 注意邊界問題\n此題有課能為不對稱矩陣，需多加判斷，避免重複計算 遍歷一行少一行，遍歷一列少一列，因為行列都有改變所以要多加判斷是否會重複遍歷 My Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public List\u0026lt;Integer\u0026gt; spiralOrder(int[][] matrix) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (matrix.length == 0 || matrix[0].length == 0) { return result; } int m = matrix.length; //row int n = matrix[0].length; //col int endRow = m - 1; int endCol = n - 1; int startx = 0; //(x, y) int starty = 0; //(x, y) int i; while(startx \u0026lt;= endRow \u0026amp;\u0026amp; starty \u0026lt;= endCol) { for(i = starty; i \u0026lt;= endCol; i++) { result.add(matrix[startx][i]); } startx++; for(i = startx; i \u0026lt;= endRow; i++) { result.add(matrix[i][endCol]); } endCol--; if(startx \u0026lt;= endRow){ for(i = endCol; i \u0026gt;= starty; i--) { result.add(matrix[endRow][i]); } endRow--; } if(starty \u0026lt;= endCol){ //判斷 因為我們上面startx++;做了更動，沒檔可能又跑進來 for(i = endRow; i \u0026gt;= startx; i--) { result.add(matrix[i][starty]); } starty++; } } return result; } } ","date":"2023-12-26T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-54.-spiral-matrix/","title":"Daily Leetcode - 54. Spiral Matrix"},{"content":"2023 Dec LC challenge 題目 59. Spiral Matrix II 代碼隨想錄-螺旋矩陣 螺旋矩陣 : 注意邊界問題\n左閉右開 (本題用這個) 左閉右閉 那如果要循環? 要轉幾圈? 題目給 n ，假設 n = 4 ，每轉一圈少兩行所以 n / 2 = 2 (另一個說法) 方陣 My Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int[][] generateMatrix(int n) { int loop = 0; int[][] res = new int[n][n]; int start = 0; int count = 1; int i, j; while(loop \u0026lt; n / 2) { loop++; for (j = start; j \u0026lt; n - loop; j++) { res[start][j] = count++; } for (i = start; i \u0026lt; n - loop; i++) { res[i][j] = count++; } for (; j \u0026gt;= loop; j--) { res[i][j] = count++; } for (; i \u0026gt;= loop; i--) { res[i][j] = count++; } start++; } if (n % 2 == 1) { res[start][start] = count; } return res; } } ","date":"2023-12-26T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-59.-spiral-matrix-ii/","title":"Daily Leetcode - 59. Spiral Matrix II"},{"content":"2023 Dec LC challenge 題目 2089. Find Target Indices After Sorting Array 用兩次二分法找target最初位置到最後一個位置的所有滿足target的索引。\nMy Code 方法一 二分法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public List\u0026lt;Integer\u0026gt; targetIndices(int[] nums, int target) { Arrays.sort(nums); List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int start = findPosition(nums, target, true); if (start == nums.length || nums[start] != target) return ans; int end = findPosition(nums, target, false) - 1; for (int i = start; i \u0026lt;= end; i++) { ans.add(i); } return ans; } public int findPosition(int[] nums, int target, boolean findStart) { int left = 0; int right = nums.length; while(left \u0026lt; right) { int mid = left + (right - left)/2; if(nums[mid] \u0026gt; target || findStart \u0026amp;\u0026amp; nums[mid] == target) { right = mid; } else{ left = mid + 1; } } return left; } } 方法二 計數器活用 利用兩個計數器\n一個計算出現target的次數 一個計算小於target的次數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List\u0026lt;Integer\u0026gt; targetIndices(int[] nums, int target) { int equalCount = 0; int lessCount = 0; for(int num : nums) { if(num == target) equalCount++; if(num \u0026lt; target) lessCount++; } List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; equalCount; i++) { result.add(lessCount+i); } return result; } } 假設我們有陣列 nums = [1, 2, 4, 3, 2, 4, 4] 和目標值 target = 4。\n計算 lessCount 和 equalCount：\n遍歷數組 nums，我們發現 1, 2, 2, 3 這四個元素小於 4（target），所以 lessCount = 4。 同時，有三個元素等於 4（target），所以 equalCount = 3。 建立結果列表：\n由於有 4 個元素小於 4，這意味著第一個等於 4 的元素的索引是 4（因為陣列索引從 0 開始）。 所以，lessCount 就是等於 target 的第一個元素的索引。 我們需要將 equalCount（即 3）個索引新增到結果清單中，這些索引分別是 4, 5, 6（這是因為在我們的範例陣列中，4 這個值連續出現了三次）。 因此，for 迴圈中的 result.add(lessCount + i); 將會計算並加入這些索引：\n第一次迴圈時，i = 0，所以新增的索引是 lessCount + 0 = 4。 第二次迴圈時，i = 1，所以加入的索引是 lessCount + 1 = 5。 第三次循環時，i = 2，所以新增的索引是 lessCount + 2 = 6。 最終，result 列表將包含 [4, 5, 6]，這就是數組 nums 中所有等於 4 的元素的索引。\n","date":"2023-12-25T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-2089.-find-target-indices-after-sorting-array/","title":"Daily Leetcode - 2089. Find Target Indices After Sorting Array"},{"content":"2023 Dec LC challenge 題目 34. Find First and Last Position of Element in Sorted Array 用兩次二分法找target最初位置以及最後一個位置\nMy Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int[] searchRange(int[] nums, int target) { int start = findPosition(nums, target, true); if (start == nums.length || nums[start] != target) { return new int[]{-1, -1}; } int end = findPosition(nums, target, false)-1; //目標值的結束位置的下一個位置」調整回「目標值的實際結束位置。 return new int[]{start, end}; } public int findPosition(int[] nums, int target, boolean findStart) { int left = 0; int right = nums.length; while(left \u0026lt; right) { int mid = left + (right - left)/2; if(nums[mid] \u0026gt; target) { right = mid; } else if(nums[mid] \u0026lt; target) { left = mid + 1; } else if( findStart \u0026amp;\u0026amp; nums[mid] == target) { // 找起始位置 right = mid; } else { left = mid + 1; } } return left; } } ","date":"2023-12-25T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-34.-find-first-and-last-position-of-element-in-sorted-array/","title":"Daily Leetcode - 34. Find First and Last Position of Element in Sorted Array"},{"content":"Angular 簡介 Angular is a framework for building modern single-page applications.\n關於 TypeScript TypeScript 是一種由微軟開發的開源程式語言。 它是JavaScript的一個超集，增加了可選的靜態類型和基於類別的物件導向程式設計。\n以下是TypeScript的一些主要特點： 靜態型別檢查： 與JavaScript不同的是，TypeScript在程式碼編寫階段就能檢查型別錯誤。 這意味著開發者可以在程式碼運行之前發現並修正錯誤，這有助於提高程式碼品質和可維護性。\n類型推斷： TypeScript能夠自動推斷變數的類型，減少了顯示類型宣告的需要。\n支援最新的JavaScript特性： TypeScript支援ECMAScript標準的最新特性，例如箭頭函數、非同步/等待等，並將它們編譯成舊版本的JavaScript，以確保相容性。\n豐富的IDE支援： 由於具有類型訊息，TypeScript在整合開發環境（IDE）中能提供更好的自動完成、導航和重構功能。\n類別、介面和模組： TypeScript支援基於類別的物件導向編程，包括類別、介面和模組等概念，這使得建立大型應用程式更為方便。\n跨瀏覽器、跨裝置、跨平台：TypeScript最終被編譯為JavaScript，因此可以在任何支援JavaScript的瀏覽器、裝置或平台上執行。\n社群支持與生態系統：TypeScript由於微軟的支持和廣泛的社群參與，具有豐富的生態系統，包括大量的函式庫和工具。\nTypeScript特別適合用於開發大型或複雜的JavaScript應用程序，它提供了強大的工具和實踐來管理大型程式碼庫和團隊。\ncompile the code web browsers do not understand Typescript natively, have to convert to JS code.\nThis is known as \u0026ldquo;transpiling\u0026rdquo;.\ntrsnspiling : translating / compiling.\n\u0026ldquo;Transpiling\u0026rdquo;（或稱為\u0026quot;原始碼到原始碼編譯\u0026quot;）是一個程式設計術語，指的是將一種程式語言的原始程式碼轉換為另一種語言的等效程式碼。 這個過程不同於傳統的編譯，因為它通常涉及兩種高階語言之間的轉換，而不是將高階語言轉換為低階語言（如組合語言或機器碼）。\n在TypeScript的上下文中，transpiling是一個非常重要的概念。 TypeScript是JavaScript的一個超集，這意味著任何有效的JavaScript程式碼也是有效的TypeScript程式碼。 但是，TypeScript增加了一些不屬於JavaScript的特性，例如靜態類型檢查和更豐富的物件導向程式設計模型。 這些特性在執行時期的JavaScript環境中並不存在。\nmydemo.ts ==== tsc ====\u0026gt; mydemo.js\n","date":"2023-12-22T13:00:00Z","permalink":"https://rickyhsieh.github.io/p/angular-crash-introduction/","title":"Angular crash Introduction"},{"content":"2023 Dec LC challenge 題目 189. Rotate Array Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\nMy Code 方法一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public void rotate(int[] nums, int k) { int len = nums.length; int[] result = new int[len]; k = k % len; for(int i = 0; i \u0026lt; len; i++) { result[(i+k) % len] = nums[i]; } for(int i = 0; i \u0026lt; len; i++) { nums[i] = result[i]; } } } 方法二 假設我們有一個陣列 nums = [1, 2, 3, 4, 5, 6, 7]，我們想要將它向右旋轉 k = 3 次。\n步驟 1: 調整旋轉次數 由於陣列長度是 7，我們先將 k 調整為 k % 7，這裡 k 本身是 3，所以不需要調整。\n步驟 2: 反轉整個陣列 原始數組：[1, 2, 3, 4, 5, 6, 7] 反轉後：[7, 6, 5, 4, 3, 2, 1]\n步驟 3: 反轉前 k 個元素 只反轉數組的前 3 個元素。 反轉前 3 個元素後：[5, 6, 7, 4, 3, 2, 1]\n步驟 4: 反轉剩下的 n - k 個元素 反轉從索引 3 到陣列末端的元素。 最終結果：[5, 6, 7, 1, 2, 3, 4]\n這就是陣列 [1, 2, 3, 4, 5, 6, 7] 向右旋轉 3 次後的結果。\n如何工作的？ 反轉整個數組：這一步將原來在數組後面的元素移動到前面，但這些元素的相對順序是顛倒的。 反轉前 k 個元素：這一步驟將先前移動到前面的元素恢復到正確的順序。 反轉剩餘元素：最後，將陣列剩餘部分也恢復到正確的順序。 這種方法是一種高效的旋轉數組的技巧，因為它避免了單個元素逐個移動的需要，而是透過幾次數組層級的操作來實現目標。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public void rotate(int[] nums, int k) { // adjusting the value of k accouding to nums size. k %= nums.length; // reverse entire array. reverse(nums, 0, nums.length - 1); // reverse first k element. reverse(nums, 0, k - 1); // reverse last n - k elements. reverse(nums, k, nums.length - 1); } private void reverse(int[] nums, int start, int end) { while (start \u0026lt; end) { int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; } } } ","date":"2023-12-22T13:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-189.-rotate-array/","title":"Daily Leetcode - 189. Rotate Array"},{"content":"2023 Dec LC challenge 題目 82. Remove Duplicates from Sorted List II 即在排序鏈結中刪除所有重複的節點。\n1 2 3 1 - 2 - 3 - 3 - 4 -\u0026gt; to 1 - 2 - 4 - \u0026gt; 首先會想到如何跳過重複的節點:\n我需要追蹤重複點的前一個node 以及使用啞節點（dummy node）來處理頭部可能是重複節點的情況。這是處理此類問題的常見方法。 使用while迴圈跳過重複點，while迴圈會停在最後的重複點，所以要將該重複點再往下一個點，再給dummy.next 引用。 My Code 方法一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null) return head; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy; ListNode current = head; while(current != null) { if(current.next != null \u0026amp;\u0026amp; current.val == current.next.val) { while(current.next !=null \u0026amp;\u0026amp; current.val == current.next.val) { current = current.next; } prev.next = current.next; } else { prev = current; } current = current.next; } return dummy.next; } } ","date":"2023-12-22T13:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-82.-remove-duplicates-from-sorted-list-ii/","title":"Daily Leetcode - 82. Remove Duplicates from Sorted List II"},{"content":"2023 Dec LC challenge 題目 61. Rotate List 方法 遍歷鍊錶以確定長度：確定鍊錶的長度 n（在這個例子中為 5）。\n確定旋轉點：計算旋轉 k 次後鍊錶的新尾部位置。 在這個例子中，旋轉 2 次，新尾部是第 5 - 2 = 3 個節點（即節點 3）。\n執行旋轉：斷開新尾部和後面節點的連接，並將後面的部分移到鍊錶的前面。 同時，將原來的尾部節點的 next 指向原來的頭部節點。\n做法 計算鏈結長度： 遍歷鏈結以確定其長度。 形成環： 將鏈結的尾部連接到頭部，形成一個環。 找到新尾部： 根據旋轉次數 k 和鏈結長度 length，找到新的尾部節點（newTail）。 斷開環： 在新的尾部節點斷開環，並設定新的頭部節點。 關於鏈結旋轉 length - k % length - 1 是在鏈結旋轉操作中用來決定新的尾部節點位置的:\nlength：這是鏈結的總長度。 k % length：這裡 k 是想要右旋轉鏈結的次數。 % 是模運算，k % length 計算了實際的旋轉次數，這是為了處理 k 大於鏈結長度的情況。 例如，如果鍊錶長度是 5，而 k 是 7，那麼旋轉 7 次和旋轉 2 次（因為 7 % 5 = 2）的效果是相同的。\nlength - k % length： 這一部分計算了在鍊錶中從頭節點開始到新尾部節點的距離。 為什麼要用 length - k % length 呢？ 因為右旋轉 k 次相當於將鍊錶尾部的 k % length 個節點移動到了鍊錶的開頭。\nlength - k % length - 1：\n最後，減去 1 是為了找出新尾部節點的前一個節點。 這是因為在確定新尾部之後，我們需要在該節點處斷開鍊錶，以形成新的頭部和尾部。 如果我們直接定位到新尾部，我們就沒有辦法方便地斷開鍊錶。\nMy Code 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode rotateRight(ListNode head, int k) { // 單一node、空鏈結無法rotate if(head == null || head.next == null || k == 0) return head; // 計算鏈結長度 ListNode oldTail = head; int length = 1; while(oldTail.next != null) { length++; oldTail = oldTail.next; } // 形成環 oldTail.next = head; ListNode newTail = head; for(int i = 0; i \u0026lt; length - k % length - 1 ; i++) { newTail = newTail.next; } // 遍歷結束，此時newTail是新尾部節點的前一個 ListNode newHead = newTail.next; // 斷開環 newTail.next = null; return newHead; } } ","date":"2023-12-22T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-61.-rotate-list/","title":"Daily Leetcode - 61. Rotate List"},{"content":"2023 Dec LC challenge 題目 19. Remove Nth Node From End of List 方法一 : 遍歷方式 給你一個LL以及一個n，我們要刪除後面數來第n個node， 如果從前面數來，也就是(鏈結長度 - 1 - n)個node， 要刪除node我們需要知道刪除目標的前一個是誰。\n方法二 : 快慢指標 使用快慢指標來找到正確的節點，做到這一點而不需要先計算LL的總長度。\n初始化快慢指標：這段程式碼首先宣告了兩個指標 fast 和 slow，並將它們都初始化為指向的頭節點 head。\n移動快指標：將 fast 指標向前移動 n 個節點。 這個步驟是為了在 fast 和 slow 之間建立一個長度為 n 的間隔。\n檢查快指標：如果 fast 指標在這個過程中變成了 null，這表示要刪除的節點實際上是頭節點。 在這種情況下，函數直接傳回 head.next，即刪除了頭節點。\n同時移動快慢指標：如果不需要刪除頭節點，會進入一個 while 迴圈，這個迴圈會一直持續，直到 fast 指標指向LL的最後一個節點。 在這個迴圈中，fast 和 slow 指標都會同時向前移動，但由於 fast 指標領先 slow 指標 n 個節點，所以當 fast 到達鍊錶末端時，slow 就會剛好位於要刪除節點的前一個節點。\n刪除節點：在循環結束後，slow.next 是要刪除的節點。 透過將 slow.next 設定為 slow.next.next，我們跳過了要刪除的節點，從而實現了刪除操作。\n返回鍊錶頭：最後，函數傳回更新後的鍊錶頭 head。\nMy Code 方法一 方法二 快慢指標 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode fast = head, slow = head; for (int i = 0; i \u0026lt; n; i++) fast = fast.next; // fast 先跑n步 if (fast == null) return head.next; while (fast.next != null) { fast = fast.next; // fast 指针向前移一步 slow = slow.next; // slow 指针也向前移一步 } slow.next = slow.next.next; return head; } } ","date":"2023-12-21T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-19.-remove-nth-node-from-end-of-list/","title":"Daily Leetcode - 19. Remove Nth Node From End of List"},{"content":"2023 Dec LC challenge 題目 21. Merge Two Sorted Lists 方法 My Code 方法一 iteration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode current = dummy; while(l1 != null \u0026amp;\u0026amp; l2 != null) { if(l1.val \u0026lt; l2.val) { current.next = l1; l1 = l1.next; }else{ current.next = l2; l2 = l2.next; } current = current.next; } if(l1 != null) { current.next = l1; } else if(l2 != null) { current.next = l2; } return dummy.next; } } 方法二 recursion ","date":"2023-12-21T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-21.-merge-two-sorted-lists/","title":"Daily Leetcode - 21. Merge Two Sorted Lists"},{"content":"2023 Dec LC challenge 題目 237. Delete Node in a Linked List 方法 寫一個方法來刪除一個給定的非末尾節點 node，並且規定不能從頭部開始遍歷。\n將 node 的下一個節點的值複製到 node，然後讓 node 指向它的下一個節點的下一個節點來實現。 就是修改 node 的 val 和 next 屬性。\n有效地“刪除”給定的非末尾節點。 需要注意的是，這種刪除方法實際上並沒有釋放被「刪除」節點的內存，因為它只是將其從LL的邏輯結構中移除了。 在具有垃圾收集機制的環境（如 Java）中，一旦沒有引用指向原始的下一個節點，它最終會被垃圾收集器回收。\nMy Code 方法一 1 2 3 4 5 6 class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } 刪除節點兩技巧 一、 找到並使用前驅節點進行刪除：(刪除第n個節點) 這種方法涉及遍歷linkedlist直到找到目標節點的前驅節點。 一旦找到前驅節點，您就可以透過改變前驅節點的 next 指標來跳過目標節點，從而實現刪除操作。 這是linkedlist刪除操作中最常見的方法之一，特別是當您需要刪除特定位置的節點時。\n二、直接操作 current.next 進行刪除：(刪除多節點或是根據節點的值) 這種方法在遍歷鍊錶時，不是尋找要刪除的節點，而是檢查每個節點的下一個節點（即 current.next）。 如果 current.next 是要刪除的節點，您可以透過將 current.next 設定為 current.next.next 來跳過它。\n這種方法在某些情況下更簡潔，尤其是當我需要基於節點的值來刪除節點，而不是基於節點的位置時。 兩種方法都有效，但適用於不同的情境。 第一種方法在您需要根據位置（例如刪除第 n 個節點）來刪除節點時很有用，而第二種方法在您需要根據節點的值來刪除多個節點時更為直接和高效。\n","date":"2023-12-21T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-237.-delete-node-in-a-linked-list/","title":"Daily Leetcode - 237. Delete Node in a Linked List"},{"content":"2023 Dec LC challenge 題目 876. Middle of the Linked List 方法 看到找中間值 =====\u0026gt; 考慮快慢指標(注意基數或是偶數問題)\n假設我們有一個singly LL，其節點數為奇數，例如：\n1 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; null 原本我寫的迴圈的條件是\n1 while(fast.next != null) 這表示迴圈會繼續，只要 fast.next 不是 null。 讓我們一步一步地看看會發生什麼：\n初始時，fast 和 slow 都指向頭節點（值為 1）。\n第一次循環迭代後：\nfast 將移動兩步，指向 null（因為從節點 3 移動兩步就到了LL的末端）。 slow 將移動一步，指向節點 2。 現在，因為 fast 是 null，所以在嘗試檢查 fast.next 時，程式碼將引發空指標異常。\n為了避免這個問題，正確的迴圈條件應該是 while(fast != null \u0026amp;\u0026amp; fast.next != null)。 這樣，在鍊錶長度為奇數時（如上例），當 fast 到達最後一個節點（3）時，它的 next 是 null，迴圈將在再次嘗試移動 fast 之前終止。 這就意味著 slow 將停在中間節點（在這個例子中是 2）。\n所以，修正後的程式碼能夠正確處理奇數長度的鍊錶，同時也適用於偶數長度的鍊錶。 在偶數長度的鍊錶中，slow 將指向兩個中間節點中的第二個。\nMy Code 方法一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode middleNode(ListNode head) { ListNode fast = head; ListNode slow = head; while(fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; } } ","date":"2023-12-21T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-876.-middle-of-the-linked-list/","title":"Daily Leetcode - 876. Middle of the Linked List"},{"content":"2023 Dec LC challenge 題目 206. Reverse Linked List 通常會使用到三個指標 three pointers here: prev, cur and next. My Code 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode current = head; ListNode next = null; while (current != null) { next = current.next; // 保存當前節點的下一個節點 current.next = prev; // 改變當前節點的指針指向前一個節點 prev = current; // 將 prev 和 current 向前移動 current = next; } head = prev; // 更新頭節點 return head; } 1 2 3 4 5 6 7 8 9 10 def reverseListRecursive(self, head): def reverse(cur, prev): if cur is None: return prev else: next = cur.next cur.next = prev return reverse(next, cur) return reverse(head, None) 遞迴方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public class Solution { public ListNode reverseLinkedList(ListNode head) { // 遞歸的基本情況：如果頭節點是 null 或者是最後一個節點，則不需要進一步的反轉 if (head == null || head.next == null) { return head; } // 遞歸反轉鏈表的剩餘部分 ListNode reversedListHead = reverseLinkedList(head.next); // 將當前節點的下一個節點指向當前節點，從而實現反轉 head.next.next = head; // 斷開當前節點的下一個指針，以避免循環 head.next = null; // 返回反轉後的鏈表頭節點 return reversedListHead; } } ","date":"2023-12-19T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-206.-reverse-linked-list/","title":"Daily Leetcode - 206. Reverse Linked List"},{"content":"2023 Dec LC challenge 題目 2095. Delete the Middle Node of a Linked List 使用快慢指標找到中間點在做刪除。\n快慢指標找中間點 刪除處理 My Code fast 走兩步 slow 走一步 要刪除鏈結需要知道，刪除目標的前一個節點。 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteMiddle(ListNode head) { if (head == null) return null; ListNode fast = head; ListNode slow = head; ListNode prev = null; // 刪除節點要知道前一個節點 while(fast != null \u0026amp;\u0026amp; fast.next != null) { prev = slow; slow = slow.next; fast = fast.next.next; } // slow 指向中間節點，pre 指向slow前一節點 if (prev != null) { prev.next = slow.next; } else { //是最開頭的點 head = head.next; } return head; } } 刪除節點虛擬碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function deleteNode(head, target): if head is null: return head // 空鏈結，不須刪除 if head.value == target: // 删除頭節點 head = head.next return head current = head while current.next is not null: if current.next.value == target: current.next = current.next.next // 删除下一個節點 return head current = current.next return head // 如果未找到目標節點則不變 新增節點虛擬碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function insertNode(head, newNode, position): if position == 0: // 在鏈結插入節點 newNode.next = head head = newNode return head current = head count = 0 while current is not null: count++ if count == position: // 在當前節點後插入節點 newNode.next = current.next current.next = newNode return head current = current.next // 如果 position 超出鏈結長度，可以選擇插入到尾部 // 或者根據需要執行其他操作 return head ","date":"2023-12-19T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-2095.-delete-the-middle-node-of-a-linked-list/","title":"Daily Leetcode - 2095. Delete the Middle Node of a Linked List"},{"content":"2023 Dec LC challenge 題目 2130. Maximum Twin Sum of a Linked List 使用快慢指針找到鏈表的中間點。 在遍歷過程中，反轉鏈表的前半部分。 遍歷鏈表的後半部分，同時與反轉後的前半部分進行成對求和，並記錄下最大的和。 返回記錄的最大和。 My Code 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public int pairSum(ListNode head) { // 初始化慢指針和快指針，都指向鏈表的頭部。 ListNode slow = head; ListNode fast = head; // 用於反轉鏈表的前半部分。 ListNode prev = null; ListNode temp = null; // 使用快慢指針來找到鏈表的中間點，同時反轉鏈表的前半部分。 while(fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; // 反轉鏈表的過程。 temp = slow.next; slow.next = prev; prev = slow; slow = temp; } // 如果鏈表的長度是奇數，則移動慢指針到中間點的下一個節點。(題目已知偶數) // if (fast != null) { // slow = slow.next; // } // 初始化用於記錄最大和的變量。 int max = 0; // 遍歷鏈表的後半部分，並與反轉的前半部分的對應節點進行求和。 while(slow != null) { max = Math.max(max, prev.val + slow.val); prev = prev.next; slow = slow.next; } // 返回最大和。 return max; } } 刪除節點虛擬碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function deleteNode(head, target): if head is null: return head // 空鏈結，不須刪除 if head.value == target: // 删除頭節點 head = head.next return head current = head while current.next is not null: if current.next.value == target: current.next = current.next.next // 删除下一個節點 return head current = current.next return head // 如果未找到目標節點則不變 新增節點虛擬碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function insertNode(head, newNode, position): if position == 0: // 在鏈結插入節點 newNode.next = head head = newNode return head current = head count = 0 while current is not null: count++ if count == position: // 在當前節點後插入節點 newNode.next = current.next current.next = newNode return head current = current.next // 如果 position 超出鏈結長度，可以選擇插入到尾部 // 或者根據需要執行其他操作 return head ","date":"2023-12-19T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-2130.-maximum-twin-sum-of-a-linked-list/","title":"Daily Leetcode - 2130. Maximum Twin Sum of a Linked List"},{"content":"2023 Dec LC challenge 題目 661. Image Smoother An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).\nMy Code 方法一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int[][] imageSmoother(int[][] img) { int rowNums = img.length; int colNums = img[0].length; int[][] result = new int[rowNums][colNums]; for (int i = 0; i \u0026lt; rowNums; i++) { for (int j = 0; j \u0026lt; colNums; j++) { int count = 0; int sum = 0; for(int row = i - 1; row \u0026lt;= i + 1; row++) { for(int col = j - 1; col \u0026lt;= j + 1; col++) { if((row \u0026gt;= 0 \u0026amp;\u0026amp; row \u0026lt; rowNums) \u0026amp;\u0026amp; (col \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; colNums)) { sum += img[row][col]; count++; } } } result[i][j] = sum / count; } } return result; } } int[][] result = new int[rowNums][colNums]; 創建新2D array。\nint numRows = matrix.length;：這一行取得矩陣的行數（numRows）。\nint numCols = matrix[0].length;：這一行取得矩陣的列數（numCols）。\nfor (int i = 0; i \u0026lt; numRows; i++) {：這是一個嵌套的for循環，用於遍歷矩陣的行。\nfor (int j = 0; j \u0026lt; numCols; j++) {：這是內部的巢狀for循環，用於遍歷矩陣的列。\nint sum = 0;：這一行初始化了一個變數sum，用於儲存元素及其周圍元素的總和。\nint count = 0;：這一行初始化了一個變數count，用來儲存參與平均值計算的元素個數。\nfor (int row = i - 1; row \u0026lt;= i + 1; row++) {：這是一個巢狀的for循環，用於遍歷目前元素的周圍行。\nfor (int col = j - 1; col \u0026lt;= j + 1; col++) {：這是內部的巢狀for循環，用於遍歷目前元素的周圍列。\nif (row \u0026gt;= 0 \u0026amp;\u0026amp; row \u0026lt; numRows \u0026amp;\u0026amp; col \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; numCols) {：這一行檢查目前行和列是否在矩陣的有效範圍內。\nsum += matrix[row][col];：如果在有效範圍內，將目前元素的值加到sum中。\ncount++;：每次參與平均值計算的元素個數加1。\nsum / count;：這一行計算平均值，並將結果儲存於average變數中。\n重點在於 for (int row = i - 1; row \u0026lt;= i + 1; row++) {：用於遍歷目前元素的周圍行。 i是外層循環中的目前行索引。 這個循環從i-1開始，一直遍歷到i+1，即包括當前行和當前行的上下相鄰兩行。 這樣就可以考慮到當前元素上下相鄰的行。\nfor (int col = j - 1; col \u0026lt;= j + 1; col++) {：用於遍歷目前元素的周圍列。 j是外層循環中的目前列索引。 這個循環從j-1開始，一直遍歷到j+1，也就是包含目前列和目前列的左右相鄰兩列。 這樣可以考慮到目前元素左右相鄰的列。\nif (row \u0026gt;= 0 \u0026amp;\u0026amp; row \u0026lt; numRows \u0026amp;\u0026amp; col \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; numCols) {：這一行用來檢查目前行和列是否在矩陣的有效範圍內。 確保我們不會存取矩陣之外的行和列，防越界。 row \u0026gt;= 0確保行索引不會小於0（在矩陣的上邊界內），row \u0026lt; numRows確保行索引不會大於等於矩陣的行數，col \u0026gt;= 0和col \u0026lt; numCols類似地檢查列索引。\n","date":"2023-12-19T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-661.-image-smoother/","title":"Daily Leetcode - 661. Image Smoother"},{"content":"2023 Dec LC challenge 題目 2352 equal row and column pairs Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.\nA row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).\nMy Code 使用map， 先找出每一Row 的值，用 StringBuilder 製成 rowMap 的 key。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int equalPairs(int[][] grid) { int n = grid.length; //方陣 Map\u0026lt;String, Integer\u0026gt; rowMap = new HashMap\u0026lt;\u0026gt;(); int pair = 0; for (int i = 0; i \u0026lt; n; i++) { StringBuilder sb = new StringBuilder(); for (int j = 0; j \u0026lt; n; j++) { sb.append(grid[i][j]).append(\u0026#34;,\u0026#34;); } rowMap.put(sb.toString(), rowMap.getOrDefault(sb.toString(), 0) + 1); } for (int j = 0; j \u0026lt; n; j++) { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; n; i++) { sb.append(grid[i][j]).append(\u0026#34;,\u0026#34;); } pair += rowMap.getOrDefault(sb.toString(), 0); } return pair; } } 法二 : 使用轉置矩陣 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int equalPairs(int[][] grid) { int pair = 0; int[][] rowSet = grid; // row 就原本的 row int[][] colSet = new int[grid.length][grid[0].length]; //轉置矩陣 for (int i = 0; i \u0026lt; grid.length; i++) { for (int j = 0; j \u0026lt; grid[0].length; j++){ colSet[j][i] = grid[i][j]; } } //比較兩個矩陣 for (int i = 0; i \u0026lt; rowSet.length; i++) { for (int j = 0; j \u0026lt; colSet.length; j++) { if (Arrays.equals(rowSet[i], colSet[j])) { pair++; } } } return pair; } } 轉置舉例:\n1 2 3 grid = [[1, 2, 3], [2, 3, 4], [3, 4, 5]] 轉置grid獲得 :\n1 2 3 colSet = [[1, 2, 3], [2, 3, 4], [3, 4, 5]] rowSet(原grid) 與 colSet做比較。\n","date":"2023-12-18T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-2352-equal-row-and-column-pairs/","title":"Daily Leetcode - 2352 equal row and column pairs"},{"content":"2023 Dec LC challenge 題目 394. Decode String My Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public String decodeString(String s) { Stack\u0026lt;String\u0026gt; strStack = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;Integer\u0026gt; numStack = new Stack\u0026lt;\u0026gt;(); StringBuilder currentString = new StringBuilder(); int num = 0; for(char c: s.toCharArray()) { if (Character.isDigit(c)) { num = num * 10 + c - \u0026#39;0\u0026#39;; } else if (c == \u0026#39;[\u0026#39;) { numStack.push(num); strStack.push(currentString.toString()); num = 0; currentString = new StringBuilder(); } else if (c == \u0026#39;]\u0026#39;) { StringBuilder temp = new StringBuilder(strStack.pop());//從 strStack 彈出一個， int repeatTimes = numStack.pop(); for (int i = 0; i \u0026lt; repeatTimes; i++) { temp.append(currentString); } currentString = temp; } else { currentString.append(c); } } return currentString.toString(); } } 目標是解碼這個字串，根據編碼規則將其轉換成 \u0026ldquo;accaccacc\u0026rdquo;。 以下是如何使用程式碼來達到這個目的：\n初始化：\nnumStack 和 strStack 都是空的。 currentString 是空的。 num 是 0。\n遍歷字串：\n遇到 \u0026lsquo;3\u0026rsquo;，num 變成 3。 遇到 \u0026lsquo;[\u0026rsquo;，將 num（3）推入 numStack，將 currentString（空）推入 strStack，重置 num 和 currentString。 遇到 \u0026lsquo;a\u0026rsquo;，currentString 變成 \u0026ldquo;a\u0026rdquo;。 遇到 \u0026lsquo;2\u0026rsquo;，num 變成 2。 遇到 \u0026lsquo;[\u0026rsquo;，將 num（2）推入 numStack，將 currentString（\u0026ldquo;a\u0026rdquo;）推入 strStack，重置 num 和 currentString。 遇到 \u0026lsquo;c\u0026rsquo;，currentString 變成 \u0026ldquo;c\u0026rdquo;。 遇到 \u0026lsquo;]\u0026rsquo;，numStack.pop() 是 2，strStack.pop() 是 \u0026ldquo;a\u0026rdquo;。 將 \u0026ldquo;c\u0026rdquo; 重複 2 次，得到 \u0026ldquo;cc\u0026rdquo;，然後拼接到 \u0026ldquo;a\u0026rdquo; 上，currentString 變成 \u0026ldquo;acc\u0026rdquo;。 遇到 \u0026lsquo;]\u0026rsquo;，numStack.pop() 是 3，strStack.pop() 是空。 將 \u0026ldquo;acc\u0026rdquo; 重複 3 次，得到 \u0026ldquo;accaccacc\u0026rdquo;。 最終結果：\n遍歷結束，currentString 是 \u0026ldquo;accaccacc\u0026rdquo;，這是解碼後的字串。 在整個過程中，兩個堆疊 numStack 和 strStack 起到了關鍵作用。 每當遇到 \u0026lsquo;[\u0026rsquo;，就會將當前的重複次數和字串保存起來，然後重置這些變數以準備解析下一個括號內的字串。 每當遇到 \u0026lsquo;]\u0026rsquo;，就會從堆疊中恢復先前儲存的重複次數和字串，並根據重複次數將當前字串重複並拼接，直到整個字串被完全解析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Res { StringBuilder sb; int end; Res(int end) { this.sb = new StringBuilder(); this.end = end; } } class Solution { private Res solve(String s, int idx) { int n = s.length(); StringBuilder str = new StringBuilder(); StringBuilder numSb = new StringBuilder(); Res ans = new Res(idx); int i = idx; while (i \u0026lt; n) { char c = s.charAt(i); if (c == \u0026#39;[\u0026#39;) { Res res = solve(s,i+1); int num = Integer.parseInt(numSb.toString()); for (int j = 0; j \u0026lt; num; ++j) { ans.sb.append(res.sb); } i = res.end+1; numSb = new StringBuilder(); } else if (c == \u0026#39;]\u0026#39;) { // ans.sb.append(str); ans.end = i; break; } else if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { numSb.append(c); ++i; } else { ans.sb.append(c); ++i; } } return ans; } public String decodeString(String s) { return solve(s,0).sb.toString(); } } ","date":"2023-12-18T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-394-decode-string/","title":"Daily Leetcode - 394 Decode String"},{"content":"關於 在Spring框架中，HttpEntity和ResponseEntity是處理HTTP請求和響應的兩個核心概念。 它們都屬於Spring的Web模塊。\nHttpEntity HttpEntity是一個抽象的概念，表示HTTP請求或響應的整體，包括其中的 headers 和主體内容(body)。它用於封裝HTTP請求的數據，在Spring的RestTemplate中經常用到。你可以使用HttpEntity來設置請求頭和請求主體，然後將它傳遞給RestTemplate以發送HTTP請求。\n1 2 3 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;String\u0026gt; entity = new HttpEntity\u0026lt;String\u0026gt;(\u0026#34;parameters\u0026#34;, headers); ResponseEntity ResponseEntity是HttpEntity的一個子類別，它表示由服務器發送的含有HTTP狀態碼、header 和 body 的 response 。ResponseEntity特別用於Spring MVC的controller中，可以讓你更精細地控制返回給客戶端的響應。 例如，你可以設置狀態碼、response header和response body。\n1 ResponseEntity\u0026lt;String\u0026gt; responseEntity = new ResponseEntity\u0026lt;String\u0026gt;(\u0026#34;Response Body\u0026#34;, headers, HttpStatus.OK); HttpEntity是一個更一般的概念，可以代表HTTP請求或響應，而ResponseEntity專門代表一個response。 ResponseEntity繼承自HttpEntity，添加了一些額外的功能，比如設置HTTP狀態碼。 在Spring的REST API中，當你想要完全控制響應時（包括狀態碼和header），通常使用ResponseEntity。 如果你只需要傳遞數據和頭信息，不關心響應的狀態碼，則可以使用HttpEntity。 總的來說，ResponseEntity是用於創建HTTP響應的更專門的工具，而HttpEntity則更多用於客戶端的HTTP請求。在服務器端編程中，當需要對HTTP響應進行精細控制時，應該選擇使用ResponseEntity。\n","date":"2023-12-18T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/httpentityb-%E5%92%8C-responseentityb/","title":"HttpEntity\u003cB\u003e 和 ResponseEntity\u003cB\u003e"},{"content":"2023 Dec LC challenge 外掛 Edit Starters 如果要裝 Lombok 的話，可以到 pom 去 right click \u0026gt; [ generate ] \u0026gt; [edit starter] \u0026gt; 出現spring initializr Url (保持預設)按ok \u0026gt; 在Edit Starter中按developer tool \u0026gt; 點擊 lombok My Code ","date":"2023-12-18T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/intellij-%E5%A4%96%E6%8E%9B%E7%A8%8B%E5%BC%8F%E5%A5%BD%E7%94%A8%E7%9A%84tip/","title":"Intellij - 外掛程式、好用的tip"},{"content":"2023 Dec LC challenge 題目 2353. Design a Food Rating System topic\npriorityQueue HashMap My Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class FoodRatings { public class Info { String food; String cuisine; int rating; Info(String food, String cuisine, int rating) { this.food = food; this.cuisine = cuisine; this.rating = rating; } } Map\u0026lt;String, Info\u0026gt; foodMap; Map\u0026lt;String, PriorityQueue\u0026lt;Info\u0026gt;\u0026gt; cuisineMap; public FoodRatings(String[] foods, String[] cuisines, int[] ratings) { foodMap = new HashMap\u0026lt;\u0026gt;(); cuisineMap = new HashMap\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; foods.length; i++) { Info info = new Info(foods[i], cuisines[i], ratings[i]); foodMap.put(foods[i], info); if(cuisineMap.containsKey(cuisines[i])) { cuisineMap.get(cuisines[i]).add(info); }else{ PriorityQueue\u0026lt;Info\u0026gt; pq = new PriorityQueue\u0026lt;Info\u0026gt;(new Comparator\u0026lt;Info\u0026gt;(){ @Override public int compare(Info a, Info b) { int result = b.rating - a.rating; if (result == 0) { return (a.food).compareTo(b.food); } return result; } }); pq.add(info); cuisineMap.put(cuisines[i],pq); } } } public void changeRating(String food, int newRating) { Info prev = foodMap.get(food); Info curr = new Info(food, prev.cuisine, newRating); foodMap.put(food, curr); prev.food = \u0026#34;\u0026#34;; cuisineMap.get(prev.cuisine).add(curr); } public String highestRated(String cuisine) { while( cuisineMap.get(cuisine).peek().food.equals(\u0026#34;\u0026#34;)){ cuisineMap.get(cuisine).remove(); } return cuisineMap.get(cuisine).peek().food; } } /** * Your FoodRatings object will be instantiated and called as such: * FoodRatings obj = new FoodRatings(foods, cuisines, ratings); * obj.changeRating(food,newRating); * String param_2 = obj.highestRated(cuisine); */ foodMap結構 1 2 3 4 5 6 foodMap = { \u0026#34;kimchi\u0026#34;: Info(\u0026#34;kimchi\u0026#34;, \u0026#34;korean\u0026#34;, 5), \u0026#34;sushi\u0026#34;: Info(\u0026#34;sushi\u0026#34;, \u0026#34;japanese\u0026#34;, 8), \u0026#34;ramen\u0026#34;: Info(\u0026#34;ramen\u0026#34;, \u0026#34;japanese\u0026#34;, 7), \u0026#34;tacos\u0026#34;: Info(\u0026#34;tacos\u0026#34;, \u0026#34;mexican\u0026#34;, 6) } cuisineMap結構 1 2 3 4 5 cuisineMap = { \u0026#34;korean\u0026#34;: PriorityQueue [ Info(\u0026#34;kimchi\u0026#34;, \u0026#34;korean\u0026#34;, 5) ], \u0026#34;japanese\u0026#34;: PriorityQueue [ Info(\u0026#34;sushi\u0026#34;, \u0026#34;japanese\u0026#34;, 8), Info(\u0026#34;ramen\u0026#34;, \u0026#34;japanese\u0026#34;, 7) ], \u0026#34;mexican\u0026#34;: PriorityQueue [ Info(\u0026#34;tacos\u0026#34;, \u0026#34;mexican\u0026#34;, 6) ] } ","date":"2023-12-17T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-2353.-design-a-food-rating-system/","title":"Daily Leetcode - 2353. Design a Food Rating System"},{"content":"sliding window 模板整理 Sliding window 概念就是可以使用一個 pointer 以及一個 window size 去實作，且會利用 window 中的 elements去依照情境去使用，就不用像 two pointer 兩個 pointer 去實作。\n解題模板 滑動視窗（Sliding Window）是一種常用的解決陣列或字串問題的方法，尤其適用於需要找出滿足某種條件的最長或最短子數組/子字串的問題：\n模板結構 初始化視窗邊界和所需變數：\n初始化兩個指標 left 和 right，分別表示視窗的左右邊界。 一般情況下，兩個指標初始都指向陣列的起始位置。 根據問題需求初始化其他所需的變數（例如用於計數、求和等）。 視窗的擴展（右移右指針）：\n增加 right 指針，擴大窗口，直到視窗內的子數組/子字串滿足特定條件。 每次移動右指標後，根據需要更新所需變數的狀態。 視窗的收縮（右移左指針）：\n當視窗內的子數組/子字串滿足條件時，逐步右移 left 指標以收縮窗口，直到視窗不再滿足條件。 每次移動左指標後，同樣更新所需變數的狀態。 更新所需的結果：\n在每次視窗改變（擴展或收縮）時，根據題目要求更新結果。 重複以上步驟直到結束：\n繼續移動右指標直到陣列/字串的結尾，重複上述過程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public int slidingWindowTemplate(int[] nums) { int left = 0, right = 0; int result = 0; // 根據具體問題調整 // 可能需要的其他變數初始化 while (right \u0026lt; nums.length) { // 根據視窗內的資料更新狀態 // ... while (/* 視窗內的子數組滿足特定條件 */) { // 更新所需的結果 // ... // 移動左指針，縮小視窗 // 更新視窗狀態 left++; } // 擴充視窗 right++; } return result; } ","date":"2023-12-15T14:37:00Z","permalink":"https://rickyhsieh.github.io/p/algorithm-sliding-window-%E6%A8%A1%E6%9D%BF/","title":"Algorithm sliding window 模板"},{"content":"2023 Dec LC challenge 題目 1004. Max Consecutive Ones III Given a binary array nums and an integer k, return the maximum number of consecutive 1\u0026rsquo;s in the array if you can flip at most k 0\u0026rsquo;s.\nExample 1: Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.\nMy Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int longestOnes(int[] nums, int k) { int left = 0; int max = 0; int zeroCount = 0; for (int right = 0; right \u0026lt; nums.length; right++) { if(nums[right] == 0) { //右指針遍歷找遇到0 zeroCount++ zeroCount++; } while(zeroCount \u0026gt; k) { // 當window中的 0 大於可交換的coda k 就調整window大小(左指標移動) if(nums[left] == 0) { // 若左指標遇到0 zeroCount--; zeroCount--; } left++; } max = Math.max(max, right - left + 1); } return max; } } Example 例子: [1,1,0,1,1,1] 和 k = 2，目標是找出在最多翻轉 2 個 0 的情況下連續 1 的最大數量。\n初始狀態 nums = [1,1,0,1,1,1] k = 2 left = 0, right = 0, zeroCount = 0, max = 0 迭代步驟 第一步: right = 0\nnums[right] = 1 → zeroCount 維持不變。 max = Math.max(0, 0 - 0 + 1) = 1 → max = 1 right 移動到下一個位置。 第二步: right = 1\nnums[right] = 1 → zeroCount 維持不變。 max = Math.max(1, 1 - 0 + 1) = 2 → max = 2 right 移動到下一個位置。 第三步: right = 2\nnums[right] = 0 → zeroCount 增加到 1。 max = Math.max(2, 2 - 0 + 1) = 3 → max = 3 right 移動到下一個位置。 第四步: right = 3\nnums[right] = 1 → zeroCount 維持不變。 max = Math.max(3, 3 - 0 + 1) = 4 → max = 4 right 移動到下一個位置。 第五步: right = 4\nnums[right] = 1 → zeroCount 維持不變。 max = Math.max(4, 4 - 0 + 1) = 5 → max = 5 right 移動到下一個位置。 第六步: right = 5\nnums[right] = 1 → zeroCount 維持不變。 max = Math.max(5, 5 - 0 + 1) = 6 → max = 6 right 到達陣列末端。 結果 最大連續 1 的數量是 max = 6。 在這個範例中，由於 k = 2，允許翻轉的 0 的數量不限制視窗的擴展，因此最大連續 1 的數量等於數組的長度。 如果 k 較小或陣列中 0 的數量較多，則視窗大小和最大連續 1 的數量會有所不同。\n","date":"2023-12-15T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-1004.-max-consecutive-ones-iii/","title":"Daily Leetcode - 1004. Max Consecutive Ones III"},{"content":"2023 Dec LC challenge 題目 2390. Removing Stars From a String Given an m x n binary matrix mat, return the number of special positions in mat.\nA position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).\n[1][0][0] [0][0][1] [1][0][0]\nInput: mat = [[1,0,0],[0,0,1],[1,0,0]] Output: 1\nMy Code 解法一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int numSpecial(int[][] mat) { int specialCount = 0; int[] rowSum = new int[mat.length]; int[] colSum = new int[mat[0].length]; for (int i = 0; i \u0026lt; mat.length; i++) { for (int j = 0; j \u0026lt; mat[i].length; j++) { rowSum[i] += mat[i][j]; colSum[j] += mat[i][j]; } } for (int i = 0; i \u0026lt; mat.length; i++) { for (int j = 0; j \u0026lt; mat.length; j++) { if (mat[i][j] == 1 \u0026amp;\u0026amp; rowSum[i] == 1 \u0026amp;\u0026amp; colSum[j] == 1) { specialCount++; } } } return specialCount; } } 遇到的問題 java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2 at line 16, Solution.numSpecial at line 54, __DriverSolution__.__helper__ at line 84, __Driver__.main\n具體的例子來說明 ArrayIndexOutOfBoundsException 的原因和如何避免它。 假設我們有一個非正方形的二維數組（矩陣）mat，例如：\n1 2 3 4 int[][] mat = { {1, 0, 0}, {0, 1} }; 這個矩陣有兩行，但第一行有3個元素，第二行只有2個元素。 如果我們使用 mat[0].length（即第一行的長度）作為內層循環的界限，我們的程式碼可能看起來像這樣：\n1 2 3 4 5 for (int i = 0; i \u0026lt; mat.length; i++) { for (int j = 0; j \u0026lt; mat[0].length; j++) { // 以第一行的長度為界限 // 存取 mat[i][j] } } 時間複雜度： O(m×n)+O(m×n)=O(m×n)\n空間複雜度 儘管增加了兩個額外的數組（每行和每列的1的計數），但這些數組的大小分別是 m 和 n，所以空間複雜度是 O(m+n)。 當矩陣的大小相對較小時。\n","date":"2023-12-12T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-1582.-special-positions-in-a-binary-matrix/","title":"Daily Leetcode - 1582. Special Positions in a Binary Matrix"},{"content":"2023 Dec LC challenge 題目 1657. Determine if Two Strings Are Close 題目要求判斷兩個字串是否可以透過以下兩種操作變得相似：\n操作1：交換任意兩個現有字符。 例如，將\u0026quot;abcde\u0026quot;轉換成\u0026quot;aecdb\u0026quot;。\n操作2：將現有字符中的一個字符轉換為另一個現有字符，然後對另一個字符執行相同操作。 例如，將\u0026quot;aacabb\u0026quot;轉換成\u0026quot;bbcbaa\u0026quot;（所有的\u0026rsquo;a\u0026rsquo;變成\u0026rsquo;b\u0026rsquo;，所有的\u0026rsquo;b\u0026rsquo;變成\u0026rsquo;a\u0026rsquo;）。\n你可以使用這兩種操作來改變字串，而且可以根據需要多次應用操作。\n給定兩個字串word1和word2，如果可以通過這些操作使它們相似，則返回true；否則返回false。\nMy Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public boolean closeStrings(String word1, String word2) { if (word1.length() != word2.length()) { return false; } int[] count1 = new int[26]; int[] count2 = new int[26]; for (char c : word1.toCharArray()) { count1[c - \u0026#39;a\u0026#39;]++; } for (char c : word2.toCharArray()) { count2[c - \u0026#39;a\u0026#39;]++; } for (int i = 0; i \u0026lt; 26; i++) { if ((count1[i] == 0 \u0026amp;\u0026amp; count2[i] != 0) || (count1[i] != 0 \u0026amp;\u0026amp; count2[i] == 0)) { return false; } } Arrays.sort(count1); Arrays.sort(count2); return Arrays.equals(count1,count2); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public boolean closeStrings(String word1, String word2) { // 檢查兩個字串的長度是否相同，如果不相同則不可能是相似的 if (word1.length() != word2.length()) { return false; } // 創建兩個array，用於記錄字符的出現次數 int[] count1 = new int[26]; int[] count2 = new int[26]; // Count character frequencies in word1 for (char c : word1.toCharArray()) { count1[c - \u0026#39;a\u0026#39;]++; } // Count character frequencies in word2 for (char c : word2.toCharArray()) { count2[c - \u0026#39;a\u0026#39;]++; } // Check if the character sets (non-zero counts) are the same in both strings for (int i = 0; i \u0026lt; 26; i++) { if ((count1[i] == 0 \u0026amp;\u0026amp; count2[i] != 0) || (count1[i] != 0 \u0026amp;\u0026amp; count2[i] == 0)) { return false; } } // Sort the frequency arrays and check if they are the same Arrays.sort(count1); Arrays.sort(count2); for (int i = 0; i \u0026lt; 26; i++) { if (count1[i] != count2[i]) { return false; } } return true; } } 1 2 3 4 5 6 7 8 9 class Solution { public int gridTravaler(int m, int n) { // 檢查無效或邊界情況 if (m == 0 || n == 0) return 0; // 基本情況：只有一個格子時，只有一條路徑 if (m == 1 \u0026amp;\u0026amp; n == 1) return 1; return gridTravaler(m - 1, n) + gridTravaler(m, n - 1); } } ","date":"2023-12-12T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-1657.-determine-if-two-strings-are-close/","title":"Daily Leetcode - 1657. Determine if Two Strings Are Close"},{"content":"2023 Dec LC challenge 題目 1657. Determine if Two Strings Are Close 題目要求判斷兩個字串是否可以透過以下兩種操作變得相似：\n操作1：交換任意兩個現有字符。 例如，將\u0026quot;abcde\u0026quot;轉換成\u0026quot;aecdb\u0026quot;。\n操作2：將現有字符中的一個字符轉換為另一個現有字符，然後對另一個字符執行相同操作。 例如，將\u0026quot;aacabb\u0026quot;轉換成\u0026quot;bbcbaa\u0026quot;（所有的\u0026rsquo;a\u0026rsquo;變成\u0026rsquo;b\u0026rsquo;，所有的\u0026rsquo;b\u0026rsquo;變成\u0026rsquo;a\u0026rsquo;）。\n你可以使用這兩種操作來改變字串，而且可以根據需要多次應用操作。\n給定兩個字串word1和word2，如果可以通過這些操作使它們相似，則返回true；否則返回false。\nMy Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public boolean closeStrings(String word1, String word2) { if (word1.length() != word2.length()) { return false; } int[] count1 = new int[26]; int[] count2 = new int[26]; for (char c : word1.toCharArray()) { count1[c - \u0026#39;a\u0026#39;]++; } for (char c : word2.toCharArray()) { count2[c - \u0026#39;a\u0026#39;]++; } for (int i = 0; i \u0026lt; 26; i++) { if ((count1[i] == 0 \u0026amp;\u0026amp; count2[i] != 0) || (count1[i] != 0 \u0026amp;\u0026amp; count2[i] == 0)) { return false; } } Arrays.sort(count1); Arrays.sort(count2); return Arrays.equals(count1,count2); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public boolean closeStrings(String word1, String word2) { // 檢查兩個字串的長度是否相同，如果不相同則不可能是相似的 if (word1.length() != word2.length()) { return false; } // 創建兩個array，用於記錄字符的出現次數 int[] count1 = new int[26]; int[] count2 = new int[26]; // Count character frequencies in word1 for (char c : word1.toCharArray()) { count1[c - \u0026#39;a\u0026#39;]++; } // Count character frequencies in word2 for (char c : word2.toCharArray()) { count2[c - \u0026#39;a\u0026#39;]++; } // Check if the character sets (non-zero counts) are the same in both strings for (int i = 0; i \u0026lt; 26; i++) { if ((count1[i] == 0 \u0026amp;\u0026amp; count2[i] != 0) || (count1[i] != 0 \u0026amp;\u0026amp; count2[i] == 0)) { return false; } } // Sort the frequency arrays and check if they are the same Arrays.sort(count1); Arrays.sort(count2); for (int i = 0; i \u0026lt; 26; i++) { if (count1[i] != count2[i]) { return false; } } return true; } } 1 2 3 4 5 6 7 8 9 class Solution { public int gridTravaler(int m, int n) { // 檢查無效或邊界情況 if (m == 0 || n == 0) return 0; // 基本情況：只有一個格子時，只有一條路徑 if (m == 1 \u0026amp;\u0026amp; n == 1) return 1; return gridTravaler(m - 1, n) + gridTravaler(m, n - 1); } } ","date":"2023-12-12T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-1657.-determine-if-two-strings-are-close/","title":"Daily Leetcode - 1657. Determine if Two Strings Are Close"},{"content":"2023 Dec LC challenge 題目 67. Add Binary Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nMy Code 兩個方法意思都差不多，需要注意的是每次比對到不同時，我只把needle從頭算起，但haystack依然接續下去，這樣可能會錯過，所以，haystack 也需要回溯到最初匹配開始的下一个字符，以確保不會錯過任何潛在的匹配。\n方法一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int strStr(String haystack, String needle) { int haystackLen = haystack.length(); int needleLen = needle.length(); if (needleLen == 0) { return 0; } for (int i = 0; i \u0026lt;= haystackLen - needleLen; i++) { int j; for (j = 0; j \u0026lt; needleLen; j++) { if (haystack.charAt(i + j) != needle.charAt(j)) { break; } } if (j == needleLen) { return i; } } return -1; } } 方法二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int strStr(String haystack, String needle) { int haystacklen = haystack.length(); int needlelen = needle.length(); int needleIndex = 0; for (int i = 0; i \u0026lt; haystacklen; i++) { if (haystack.charAt(i) == needle.charAt(needleIndex)) { needleIndex++; } else { i = i - needleIndex; needleIndex = 0; } if (needleIndex == needlelen) { return i - needlelen + 1; } } return -1; } } ","date":"2023-12-11T16:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-28.-find-the-index-of-the-first-occurrence-in-a-string/","title":"Daily Leetcode - 28. Find the Index of the First Occurrence in a String"},{"content":"處理字串匹配的演算法 Knuth-Morris-Pratt (KMP) 演算法 KMP 演算法透過避免重新檢查已知不匹配的字元來提高效率。 它使用一個部分匹配表來記錄 needle 字串中的模式，這樣當發現不匹配時，演算法可以直接跳過先前已經確定不匹配的部分。 這意味著在最壞的情況下，KMP 演算法的時間複雜度為 O(n)，其中 n 是 haystack 的長度。\nBoyer-Moore 演算法 Boyer-Moore 演算法是一種更高級的字串匹配演算法，其效能通常優於 KMP。 它從右向左比較字符，利用不匹配字符的信息來跳過一些不可能的匹配位置。 這種「跳過」策略使得它在實際應用中往往比 KMP 更快，尤其是當匹配的模式較長時。\nRabin-Karp 算法 Rabin-Karp 演算法使用雜湊函數來偵測候選字串是否與目標字串匹配，這使得它在某些情況下能夠快速地排除大量不匹配的情況。 它特別適合在單一文字中尋找多個模式或在大型文字中尋找模式的情況。\n","date":"2023-12-11T16:00:00Z","permalink":"https://rickyhsieh.github.io/p/%E6%AA%A2%E6%9F%A5%E5%AD%97%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%9A%84%E6%BC%94%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97-%E7%AD%89%E5%BE%85%E8%A3%9C%E5%85%85/","title":"檢查字串匹配的演算法系列 (等待補充)"},{"content":"2023 Dec LC challenge 題目 67. Add Binary Given two binary strings a and b, return their sum as a binary string.\n將兩個Binary 字串做相加，\nMy Code 我們從兩字串最尾開始，模擬二進位計算。\n二進位 1 + 1 = 10 ，寫 0 進位，關於表保留的部分，就是取模餘數 2 % 2 = 0。 二進位進位部分，則是 2 / 2 = 1，進 1 確保有無需要進位 反轉(因為是從最後開始) 假設有兩個二進制字串 a = \u0026ldquo;101\u0026rdquo; 和 b = \u0026ldquo;110\u0026rdquo;。\n從最右邊的位開始，i = 2，j = 2（字串的最後一位索引）。\n第一次，sum = carry + a[2] + b[2] = 0 + 1 + 0 = 1。因此，sb = \u0026ldquo;1\u0026rdquo;，carry = sum / 2 = 0。\n第二次，sum = carry + a[1] + b[1] = 0 + 0 + 1 = 1。因此，sb = \u0026ldquo;11\u0026rdquo;，carry = 0。\n第三次，sum = carry + a[0] + b[0] = 0 + 1 + 1 = 2。這時，sb = \u0026ldquo;011\u0026rdquo;，carry = 1。\n因為所有位都處理完了，但 carry = 1，所以 sb = \u0026ldquo;1011\u0026rdquo;。\n反轉 sb 得到最終結果 \u0026ldquo;1101\u0026rdquo;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public String addBinary(String a, String b) { StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() - 1, carry = 0; while (i \u0026gt;= 0 || j \u0026gt;= 0) { int sum = carry; if (i \u0026gt;= 0) sum += a.charAt(i--) - \u0026#39;0\u0026#39;; if (j \u0026gt;= 0) sum += b.charAt(j--) - \u0026#39;0\u0026#39;; //兩位數相加的結果只能是0或1 //（例如，1 + 1 = 10，在二進制中，我們只寫下0，並將1進位）。 sb.append(sum % 2); carry = sum / 2; } if (carry != 0) sb.append(carry); return sb.reverse().toString(); } } carry 在這個上下文中代表進位。在二進制加法中，當兩個數字相加超過1時，就會產生進位。例如，1 + 1 = 0 (在當前位) 並且產生1的進位。carry 變量用於存儲這個進位，並在下一次迭代時將其加到下一對數字的和中。這就是為什麼在計算完當前位的和後，carry 被設置為 sum / 2，這反映了在二進制加法中進位的值。\n十進制題目 66. Plus One Easy\nYou are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0\u0026rsquo;s.\nIncrement the large integer by one and return the resulting array of digits.\n兩部分處理的是不同情況：\nfor 循環和他內部的 if 語句處理的是普通情況。如果在數組中找到一個數字小於9，則將該數字加1並立即返回修改後的數組。這是因為加1不會導致進位到更高位。\n如果整個數組都遍歷完畢（所有位都是9），則會執行循環外的code：創建一個新的、長度比原數組多1的數組 newArr。這是因為對像 999 這樣的數組加1會導致進位到一個新的最高位（變成 1000）。在這個新數組中，第一位設為1，其餘位（自動初始化為0）保持不變。然後返回這個新數組。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int[] plusOne(int[] digits) { int n = digits.length; for(int i = n - 1; i \u0026gt;= 0; i--) { if(digits[i] \u0026lt; 9) { digits[i]++; return digits; } digits[i] = 0; } int[] newArr = new int[n + 1]; newArr[0] = 1; return newArr; } } ","date":"2023-12-11T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-67.-add-binary/","title":"Daily Leetcode - 67. Add Binary"},{"content":"2023 Dec LC challenge 今天在上大提琴課前坐在711刷，好險今天題目EZ。\n題目 就是轉置矩陣， 這題比較容易， 今天又是禮拜天， 肯定要快樂水一篇。\nGiven a 2D integer array matrix, return the transpose of matrix.\nThe transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix\u0026rsquo;s row and column indices.\nMy Code 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int[][] transpose(int[][] matrix) { int row = matrix.length; int col = matrix[0].length; int[][] arr = new int[col][row]; for(int i = 0; i \u0026lt; col; i++){ for(int j = 0; j \u0026lt; row; j++){ arr[i][j] = matrix[j][i]; } } return arr; } } ","date":"2023-12-10T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-867.-transpose-matrix/","title":"Daily Leetcode 867. Transpose Matrix"},{"content":"2023 Dec LC challenge 相似題目 Binary Tree Inorder Traversal Binary Tree Postorder Traversal Binary Tree Preorder Traversal preorder、postorder、inorder traversal 特性 前序 Preorder : root -\u0026gt; left -\u0026gt; right 後序 Postorder : left -\u0026gt; right -\u0026gt; root 中序 InOrder : right -\u0026gt; left -\u0026gt; right My Code 94. Binary Tree Inorder Traversal 中序 InOrder : right -\u0026gt; left -\u0026gt; right 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { //root.left - \u0026gt; root -\u0026gt; root.right List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); inorderTraversal(root, result); return result; } private void inorderTraversal(TreeNode node, List\u0026lt;Integer\u0026gt; result) { if (node == null) return; if (node.left != null) { inorderTraversal(node.left, result); } result.add(node.val); if (node.right != null) { inorderTraversal(node.right, result); } } } 144. Binary Tree Preorder Traversal 前序 Preorder : root -\u0026gt; left -\u0026gt; right 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); preorderTraversal(result, root); return result; } public void preorderTraversal(List\u0026lt;Integer\u0026gt; result, TreeNode node) { if ( node == null) return; result.add(node.val); if (node.left != null) { preorderTraversal(result, node.left); } if(node.right != null) { preorderTraversal(result, node.right); } } } 145. Binary Tree Postorder Traversal 後序 Postorder : left -\u0026gt; right -\u0026gt; root 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); postorderTraversal(result, root); return result; } public void postorderTraversal(List\u0026lt;Integer\u0026gt; result, TreeNode node) { if (node == null) return; if (node.left != null) { postorderTraversal(result, node.left); } if (node.right != null) { postorderTraversal(result, node.right); } result.add(node.val); } } ","date":"2023-12-09T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-144.-binary-tree-preorder-traversal/","title":"Daily Leetcode 144. Binary Tree Preorder Traversal"},{"content":"2023 Dec LC challenge 關於 stack 特性 先進後出 Push(): Adds an element to the top of the stack. Pop(): Removes and returns the top element of the stack. Peek(): Returns the top element of the stack without removing it from the stack. isEmpty(): Check whether the stack is empty. push 和 pop 都發生在頂端 20. Valid Parentheses Given a string s containing just the characters \u0026lsquo;(\u0026rsquo;, \u0026lsquo;)\u0026rsquo;, \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026rsquo;, \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo;, determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.\n想法 My Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.util.Stack; public class Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) { stack.push(c); } else { if (stack.isEmpty()) return false; char top = stack.pop(); if ((c == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; top != \u0026#39;(\u0026#39;) || (c == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; top != \u0026#39;{\u0026#39;) || (c == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; top != \u0026#39;[\u0026#39;)) { return false; } } } return stack.isEmpty(); } } ","date":"2023-12-08T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-20.-valid-parentheses/","title":"Daily Leetcode 20. Valid Parentheses"},{"content":"Stack ADT 使用 Array 使用 LinkedList 使用 Array 實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class StackADT { private int maxSize; private int[] stackArray; private int top; public StackADT(int size) { maxSize = size; stackArray = new int[maxSize]; top = -1; // stack是空時，top = -1 } public void push(int value) { if (top \u0026lt; maxSize -1) { // 先檢查是否已滿 top++; stackArray[top] = value; // 先增加 top，然後儲存值 } else { throw new RuntimeException(\u0026#34;Stack is full.\u0026#34;) } } public int pop() { if (top \u0026gt;= 0) { //檢查stack頂是否為空 return stackArray[top--]; // stack 減小top } else { throw new RuntimeException(\u0026#34;Stack is empty. Cannot pop.\u0026#34;); } } public int peek() { if (top \u0026gt;= 0) { return stackArray[top]; // 返回stack頂，但不pop } else { throw new RuntimeException(\u0026#34;Stack is empty. Cannot peek.\u0026#34;); } } // 檢查是否空 public boolean isEmpty() { return top == -1; } // 檢查是否已滿 public boolean isFull() { return top == maxSize - 1; } } C++ 實做 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; class MyStack { public: MyStack() { maxSize = 100; stackArray.resize(maxSize); top = -1; } void push(int value) { if (top \u0026lt; maxSize - 1) { stackArray[++top] = value; } else { throw std::runtime_error(\u0026#34;Stack is full.\u0026#34;); } } int pop() { if (!isEmpty()) { return stackArray[top--]; } else { throw std::runtime_error(\u0026#34;Stack is empty.\u0026#34;); } } int peek() { if (!isEmpty()) { return stackArray[top]; } else { throw std::runtime_error(\u0026#34;Stack is empty.\u0026#34;); } } bool isEmpty() { return top == -1; } int size() { return top + 1; } private: std::vector\u0026lt;int\u0026gt; stackArray; int maxSize; int top; }; int main() { MyStack intStack; intStack.push(1); intStack.push(2); intStack.push(3); int topElement = intStack.pop(); bool isEmpty = intStack.isEmpty(); int stackSize = intStack.size(); std::cout \u0026lt;\u0026lt; \u0026#34;Top element: \u0026#34; \u0026lt;\u0026lt; topElement \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Stack is empty: \u0026#34; \u0026lt;\u0026lt; (isEmpty ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Stack size: \u0026#34; \u0026lt;\u0026lt; stackSize \u0026lt;\u0026lt; std::endl; return 0; } ","date":"2023-12-08T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/stack-adt-%E5%AF%A6%E4%BD%9C/","title":"Stack ADT 實作"},{"content":"2023 Dec LC challenge 1716. Calculate Money in Leetcode Bank 今天是第六天，題目是 Easy 級，看出規律後就可以解了，用了兩種方法。 迭代iteration和遞迴recursion。\nMy Code Hercy wants to save money for his first car. He puts money in the Leetcode bank every day. He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.\nIteration case 1 計算完整星期的存款： 計算完整星期數 weeks = n / 7。\n使用 for 迴圈遍歷每個完整的星期。 對於每個星期，計算總存款，初始為 $28（1週的存款），然後根據星期數增加額外的金額（每過一周，每天的存款都會增加 $1）。 這裡，28 + 7 * (week - 1) 表示每週的累積存款金額。\n因為\n周次 星期一 星期二 星期三 星期四 星期五 星期六 星期日 累計 第1周 $1 $2 $3 $4 $5 $6 $7 $28 第2周 $2 $3 $4 $5 $6 $7 $8 $35 第3周 $3 $4 $5 $6 $7 $8 $9 $42 可以看出\n每周差額為 7 (等差)，代表每一天為上一周 + 1\n以每周一比較，可以發現\n周次 星期一的存款 周累計存款公式 第1周 $1 + 0 28 + 7 * (1 - 1) = $28 第2周 $1 + 1 28 + 7 * (2 - 1) = $35 第3周 $1 + 2 28 + 7 * (3 - 1) = $42 \u0026hellip; \u0026hellip; \u0026hellip; 第n周 $1 + (n - 1) 28 + 7 * (n - 1) 總額 : 28 + 7 * (week - 1) case 2 計算剩餘天數的存款： 計算剩餘的天數 remain = n % 7。 再次使用 for 迴圈遍歷剩餘的每一天，累加每天的存款額。 每天的存款金額由當前週數（weeks）和天數（i）決定。 返回總存款：\n最後回傳 total，即累積的存款總額。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int totalMoney(int n) { int weeks = n / 7; int total = 0; int remain = n % 7; for (int week = 1; week \u0026lt;= weeks; week++) { total += 28 + 7 * (week - 1); } for (int i = 1; i \u0026lt;= remain; i++) { total += i + weeks; } return total; } } Recursion 進入遞迴-recursion-的世界 遞迴思考模式 先將一個大問題，拆解成幾個較小的問題 每個較小的問題，又能依照相同方式拆成更小的問題 每當小問題解決時，大問題也可以依靠小問題的結果來解決 每層的解決方法都是一樣的，除了最小的問題以外 根據以上幾點，我們可以不斷套用相同的函數，讓他自己幫自己解決問題 以上就是遞迴的基本核心精神\n大問題：計算連續 n 天的存款總額。\n拆解為更小的問題：\n計算連續 n-1 天的存款總額，然後加上第 n 天的存款。 第 n 天的存款金額取決於已經過去的完整週數以及當前週的天數。\n再次拆解：\n每週的存款金額比上一周多 $7（每天比對應的前一周同一天多 $1）。 每天的存款金額是當天在周中的順序（1 到 7），再加上過去的完整週數（從第 0 週開始計數）。\n最小問題和基礎情況：\n當 n = 0 時，沒有存款，總額為 0。\n遞迴解決：\n使用遞歸函數計算 n-1 天的存款總額，然後將第 n 天的存款加到這個總額上。 每次遞歸呼叫都在減少 n 的值，直到達到基礎情況（n = 0）。\n一些眉角 1 int weeks = (n - 1) / 7; 這個表達式中使用 n - 1 是為了正確地計算截至第 n 天所經過的完整星期數。 這裡的 n - 1 是基於如何計數星期的方式而決定的。\n舉例來說: 假設第一天（即 n = 1）是第一週的第一天。因此，第一週的天數是從 n = 1 到 n = 7。 如果直接使用 n / 7 來計算週數，那麼在 n = 7 時，我們會得到 7 / 7 = 1，表示已經過去了一周，並且是第二週的第一天。 但實際上，第七天仍然屬於第一週。\n簡單來說，n - 1 是為了將星期的計數與天數對齊，確保每週的天數計算從0開始，正確反映過去的完整週數。\nn = 7，int weeks = ( 7 - 1) / 7，結果 weeks = 0 n = 10，int weeks = ( 10 - 1) / 7，結果 weeks = 1 n = 14，int weeks = ( 14 - 1) / 7，結果 weeks = 1 仍然在以第一周 n = 16，int weeks = ( 16 - 1) / 7，結果 weeks = 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int totalMoney(int n) { if (n == 0) { return 0; } else { int week = (n - 1) / 7; int dayOfWeek = (n - 1) % 7; int total = week + dayOfWeek + 1; return totalMoney(n - 1) + total; } } } ","date":"2023-12-07T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-1716.-calculate-money-in-leetcode-bank/","title":"Daily Leetcode - 1716. Calculate Money in Leetcode Bank"},{"content":"2023 Dec LC challenge 60. Permutation Sequence My Code 您的 Solution 類別中的 getPermutation 方法目標是取得給定數 n 的所有排列中的第 k 個排列。 這個方法先產生所有排列，然後選擇第 k 個。 然而，這種方法在 n 較大時可能會導致逾時，因為它需要產生 n!（n 的階乘）個排列，這在 n 增大時非常耗時且耗記憶體。\n要最佳化這個問題，您可以使用一種不需要產生所有排列的方法來直接計算第 k 個排列。 這種方法是基於觀察到排列的特定模式，可以透過計算而非完全枚舉來得到結果。 以下是一個改進的實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public String getPermutation(int n, int k) { int[] array = new int[n]; for (int i = 0; i \u0026lt; n; i++) { array[i] = i + 1; } List\u0026lt;Integer\u0026gt; permuted = permute(array).get(k-1); String ans = \u0026#34;\u0026#34;; for(int i = 0; i \u0026lt; permuted.size(); i++) { ans += String.valueOf(permuted.get(i)); } return ans; } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; resultList = new ArrayList\u0026lt;\u0026gt;(); backtracking (resultList, new ArrayList\u0026lt;\u0026gt;(), nums); return resultList; } public void backtracking (List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; resultList, ArrayList tempList, int[] nums) { if (tempList.size() == nums.length) { resultList.add(new ArrayList\u0026lt;\u0026gt;(tempList)); return; } for (int num : nums) { if (tempList.contains(num)) { continue; } tempList.add(num); backtracking(resultList, tempList, nums); tempList.remove(tempList.size() - 1); } } } 字元型數字轉換為對應的整數數字 ","date":"2023-12-07T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-60.-permutation-sequence/","title":"Daily Leetcode - 60. Permutation Sequence"},{"content":"2023 Dec LC challenge 1903. Largest Odd Number in String 今天是第7天拉，題目是 Easy 級。 題目大意: 給定一個數字字串，找出最大的奇數(子字串)。\n看到這個題目第一個想法是滑動視窗，two pointer，但題目看清楚後才知道只要，注意結尾是否為基數就好， 因此我只需要一個右指標，往前移動，直到0。\n需要注意的是，轉型為數字溢出問題(轉換成int 或 long 再做比較，會爆)，因此使用字元型數字轉換為對應的整數數字。\nMy Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public String largestOddNumber(String num) { int right = num.length() - 1; while(right \u0026gt;= 0) { if ((num.charAt(right)-\u0026#39;0\u0026#39;) % 2 != 0) { return num.substring(0, right + 1); } right--; } return \u0026#34;\u0026#34;; } } 字元型數字轉換為對應的整數數字 num.charAt(right) - \u0026lsquo;0\u0026rsquo; 原理如：\nnum.charAt(right)：這部分從字串 num 中取得位於索引為 right 處的字元。\n例如，如果 num 是 \u0026ldquo;12345\u0026rdquo;，且 right 是 2，那麼 num.charAt(right) 將會是字元 \u0026lsquo;3\u0026rsquo;。\n-\u0026lsquo;0\u0026rsquo;：\n這裡的 \u0026lsquo;0\u0026rsquo; 是字元字面量，表示數字 0 的字元。 在 Java 中，每個字元都有一個與之對應的整數 ASCII 值。 例如，字元 \u0026lsquo;0\u0026rsquo; 的 ASCII 值是 48，字元 \u0026lsquo;1\u0026rsquo; 的 ASCII 值是 49，以此類推，直到字元 \u0026lsquo;9\u0026rsquo; 的 ASCII 值是 57。\n相減運算：當您從一個字元型數字中減去 \u0026lsquo;0\u0026rsquo; 時，實際上是在減去字元 \u0026lsquo;0\u0026rsquo; 的 ASCII 值。 這個操作將字元型數字轉換為其實際的整數值。 例如，\u0026lsquo;3\u0026rsquo; - \u0026lsquo;0\u0026rsquo; 相當於 51 - 48（因為字元 \u0026lsquo;3\u0026rsquo; 的 ASCII 值是 51），結果是整數 3。\n常用於處理字串中的單一數字字元。\n","date":"2023-12-07T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-1903.-largest-odd-number-in-string/","title":"Daily Leetcode -1903. Largest Odd Number in String"},{"content":"2023 Dec LC challenge 42. Trapping Rain Water 題目是 Hard 級。 題目大意: 能困住最多的雨水總量。\n想法 Hi，我使用 Two Pointers，一開始先初始化兩個指標 L 和 R，分別指向陣列的開始和結束。\n為了計算積水量，需要追蹤左側和右側的最高長條，所以分別為設定了 leftMax 和 rightMax。 這兩個變數在每次迭代中更新，確保 leftMax 和 rightMax 分別是左側和右側遇到的最高長條的高度。\n在遍歷過程中，我比較 L 和 R 處的高度。 如果 L 處的高度小於 R 處，這表示 L 處可能有積水，所以我更新 leftMax 並計算該位置的積水量。 同理，如果 R 處的高度小於或等於 L 處，我會去更新 rightMax 並計算該位置的積水。\n這個過程一直持續到 L 和 R 相遇，最後累積的積水量就是整體的雨水量~~\n雙指針初始化： 初始化兩個指標 L 和 R，分別指向陣列的開始和結束位置。\n雨水累積的條件： 雨水的累積取決於每個位置左右兩側的最高長條圖，具體而言，是左右兩側的「最短」最高長條。\nleftMax 和 rightMax 的角色： leftMax 和 rightMax 用於儲存左側和右側遍歷過程中遇到的最高長條的高度。 這兩個變數可以幫助確定每個位置能夠累積多少雨水。\n比較 L 和 R 的高度： 如果 L 處的高度小於 R 處的高度，那麼 L 處有潛在的雨水累積空間。 此時應更新 leftMax 並計算可能的積水量。 反之，若 R 處的高度小於或等於 L 處的高度，應更新 rightMax 並計算右側可能的積水量。\n計算積水量： 如果 leftMax 大於目前 L 處的高度，積水量為 leftMax - height[L]。 同理，如果 rightMax 大於目前 R 處的高度，積水量為 rightMax - height[R]。\n移動指針和累積總雨水量： 在處理完目前位置後，對應的指標（L 或 R）需要向中間移動。 同時，每次計算出的積水量應會累積到總雨水量中。\nMy Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public int trap(int[] height) { int left = 0; int right = height.length - 1; int leftMax = height[0]; int rightMax = height[height.length - 1]; int total = 0; while( left \u0026lt; right) { if (height[left] \u0026lt; height[right]) { leftMax = Math.max(leftMax,height[left]); if (leftMax \u0026gt; height[left]) { total += leftMax - height[left]; } left++; } else { rightMax = Math.max(rightMax, height[right]); if (rightMax \u0026gt; height[right]) { total += rightMax - height[right]; } right--; } } return total; } } Complexity Time complexity:O(n)，其中 n 是陣列 height 的長度。\nSpace complexity: O(1)\n","date":"2023-12-07T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-42.-trapping-rain-water/","title":"Daily Leetcode 42. Trapping Rain Water"},{"content":"2023 Dec LC challenge 606. Construct String from Binary Tree Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.\nOmit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.\n想法 使用遞迴\n第一版 : 一開始的方法是先找到點，再處理括號字串，犯了一個小錯誤，因為使用String，而沒有考慮到可能會劇烈的修改字串(插入括弧或值)，而造成效能低落，原因為我每次修改String，當我使用 + 算符來連接字串時，每次操作實際上都會創建一個新的字串，因為字串在 Java 中是不可變的。這會導致在連接大量字符串時性能降低。 改法 StringBuilder 可在不創建新對象的情況下添加或修改字串。\n第二版 : 避免不必要的遞歸調用：在這個的實現中，即使左子樹或右子樹為 null，也會進行遞迴調用。可以通過直接檢查子節點是否為 null 來避免這些不必要的調用。 直接使用 StringBuilder 進行遞歸：目前先遞迴並創建左右子樹的字串，然後再將它們添加到 StringBuilder。相反的，可以直接在遞歸函數中使用 StringBuilder，這樣可以避免創建額外的字串。\n第三版(查別人的解法) : 定義為 static 可能會對性能有輕微的提升。這種性能提升（如果存在的話）的原因主要是與如何存取靜態方法相比於實例方法有關：\n存取控制：靜態方法屬於類本身而不是類的實例。因此，它們不需要存取和操作對象的實例變量。這意味著調用靜態方法時不需要創建類的實例，這可能稍微減少了記憶體的使用和管理開銷。\n內聯優化：在某些情況下，靜態方法可以更容易被JVM（Java虛擬機）進行內聯優化。內聯是一種優化，其中方法的內容直接插入到調用點，從而節省了方法調用的開銷。然而，這種優化也可能適用於非靜態方法，特別是在現代JVM實現中。\n語義清晰：將方法定義為靜態的，意味著它不依賴於對象的內部狀態。這可以讓編譯器和JVM更容易進行一些優化，因為它們不需要關心對象狀態的變化。\nMy Code 第一版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public String tree2str(TreeNode root) { // preorder traversal way StringBuilder sb = new StringBuilder(); String result = tree2sb(sb, root); return result; } public String tree2sb(StringBuilder sb, TreeNode root) { if (root == null) return \u0026#34;\u0026#34;; sb.append(root.val); if (root.left != null || root.right != null) { sb.append(\u0026#34;(\u0026#34;); tree2sb(sb, root.left); sb.append(\u0026#34;)\u0026#34;); if (root.right != null) { sb.append(\u0026#34;(\u0026#34;); tree2sb(sb, root.right); sb.append(\u0026#34;)\u0026#34;); } } return sb.toString(); } } 第二版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public String tree2str(TreeNode root) { // preorder traversal way StringBuilder sb = new StringBuilder(); String result = tree2sb(sb, root); return result; } public String tree2sb(StringBuilder sb, TreeNode root) { if (root == null) return \u0026#34;\u0026#34;; sb.append(root.val); if (root.left != null || root.right != null) { sb.append(\u0026#34;(\u0026#34;); tree2sb(sb, root.left); sb.append(\u0026#34;)\u0026#34;); if (root.right != null) { sb.append(\u0026#34;(\u0026#34;); tree2sb(sb, root.right); sb.append(\u0026#34;)\u0026#34;); } } return sb.toString(); } } 第三版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public String tree2str(TreeNode root) { // Using StringBuilder for efficient string concatenation StringBuilder sb = new StringBuilder(); // Calling the helper method with StringBuilder and the root of the tree tree2sb(sb, root); // Converting the StringBuilder to a string and returning it return sb.toString(); } public static void tree2sb(StringBuilder sb, TreeNode root) { // If the current node is null, return immediately if (root == null) return; // Append the value of the current node to the StringBuilder sb.append(root.val); // Check if parentheses are needed. Parentheses are added if either left or right child is not null if (root.left != null || root.right != null) { sb.append(\u0026#34;(\u0026#34;); // Recursively call for the left child tree2sb(sb, root.left); sb.append(\u0026#34;)\u0026#34;); // Process the right child, only if it\u0026#39;s not null if (root.right != null) { sb.append(\u0026#34;(\u0026#34;); // Recursively call for the right child tree2sb(sb, root.right); sb.append(\u0026#34;)\u0026#34;); } } } } Complexity 時間複雜度：\n這個方法執行了一次深度優先搜索（DFS）。 在遍歷過程中，每個節點被訪問一次且只一次。 因此，時間複雜度主要取決於樹中節點的總數。 如果樹中有 n 個節點，則時間複雜度是O(n)。 空間複雜度：\n空間複雜度主要來自於遞歸調用的堆棧空間和 StringBuilder 的使用。 在最壞情況下（樹完全不平衡），遞歸的深度可以達到樹的高度，即O(n)。 但對於平衡的二叉樹，遞歸的深度是O(logn)。 StringBuilder 的空間複雜度取決於最終生成的字符串長度。由於結果字符串長度與樹中節點數量成正比，因此這部分的空間複雜度也是O(n)。\n","date":"2023-12-07T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/daily-leetcode-606.-construct-string-from-binary-tree/","title":"Daily Leetcode 606. Construct String from Binary Tree"},{"content":"What is Filesystem Snapshot 文件系統快照（FileSystem Snapshot）是在特定時刻對文件系統狀態進行的完整記錄，類似於對文件系統進行的一次“照相”，捕捉那一刻文件和目錄的準確狀態。這項功能在需要資料保護和備份的計算環境中非常有用。\n文件系統快照的關鍵特點包括：\n資料保護：快照可以在不中斷服務的情況下創建，提供了一種快速回到某個時間點狀態的方法，這對於資料保護策略極其重要。\n恢復點：在發生資料遺失或損毀時，快照能夠用來迅速回滾到之前的狀態。\n效率：與傳統的備份相比，快照通常更高效，因為它們僅記錄從上一次快照後發生的改變。這種方法通常被稱為增量備份或差異備份。\n即時創建：大多數現代的文件系統和儲存方案都能在不到一秒鐘的時間內創建快照。\n節省空間：一開始的快照通常不會占用太多空間，因為它們使用原有數據的引用，隻有當數據發生變更時，才會實際佔用更多空間。\n易於管理：在許多儲存系統中，快照的創建和管理都非常簡單，無需複雜的配置。\n不同的操作系統和儲存技術有不同的文件系統快照實現方式。例如，ZFS和Btrfs等文件系統內建了快照功能。企業級儲存系統如SAN（儲存區域網絡）或NAS（網絡附加儲存）裝置通常將快照作為標準配置。在雲計算環境中，如AWS或Azure，快照也是資料保護和管理的基礎服務之一。\n","date":"2023-11-29T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/filesystem-snapshot/","title":"FileSystem Snapshot"},{"content":"what is Lexicographical Comparison ? \u0026ldquo;字典序比較\u0026rdquo;（Lexicographical Comparison）是電腦科學中用來比較兩個字串的一種方法。 它的基本原理是按照字符的順序逐個比較字串中的字符，就像在字典中查找單字一樣。\n這種比較方式在多種程式設計場景中非常有用，包括字串排序、資料庫查詢最佳化和文字處理等。\n基本原理 字元比較：字典序比較從兩個字串的第一個字元開始，逐一比較對應位置的字元。 Unicode/ASCII 值：比較基於字元的Unicode或ASCII值。 Unicode是一個國際標準，定義了文字字元的數字編碼，而ASCII是Unicode的一個子集，只包含英文字元和控製字元。 終止條件：這種比較會持續到找到不同的字符，或者某個字串先到達末尾。 應用場景 字串排序：在陣列或清單排序時，經常使用字典序作為標準。 資料庫查詢：資料庫中的字串欄位經常根據字典序進行索引和查詢。 文字搜尋：在文字搜尋中，字典序可以用來快速定位和比較字串。\nHere is my code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import java.util.Scanner; public class Solution { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String A = sc.next(); String B = sc.next(); // Sum the lengths of A and B System.out.println(A.length() + B.length()); // Determine if A is lexicographically larger than B System.out.println(A.compareTo(B) \u0026gt; 0 ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;); // Capitalize the first letter of A and B and print them System.out.println(capitalizeFirstLetter(A) + \u0026#34; \u0026#34; + capitalizeFirstLetter(B)); } public static String capitalizeFirstLetter(String input) { if (input == null || input.isEmpty()) { return input; } return input.substring(0, 1).toUpperCase() + input.substring(1); } } ","date":"2023-11-28T00:00:00Z","image":"https://rickyhsieh.github.io/p/hackerrank-java-lexicographical-comparison/hk-cover2_hu468eb36026cd721fd2f3e4d5b434dfd0_220995_120x120_fill_q75_box_smart1.jpg","permalink":"https://rickyhsieh.github.io/p/hackerrank-java-lexicographical-comparison/","title":"HackerRank - Java Lexicographical Comparison"},{"content":"Backtracking Backtracking是一種解決問題的算法，常用於在潛在解的空間中搜索。它是一種遞歸方法，採取試錯的思路來達到問題的解決。當它選擇的路徑導致無解時，它會回退（Backtrack）到之前的步驟，然後嘗試另一條路徑。Backtracking特別適用於解決排列、組合和分割問題。\n在每一步，Backtracking都會考慮所有可行的選項。如果一個選項最終導致了死胡同，算法就會回退並嘗試另一個選項，直到找到所有可能的解決方案或確定沒有解決方案。這種方法既有系統又高效，特別是在解決空間龐大的問題時。\nBacktracking\nMy Code ","date":"2023-11-27T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/algorithm-backtracking/","title":"Algorithm backtracking"},{"content":"Permutation Backtracking My Code LeetCode\n46. Permutations 使用 遞迴 使用 trackBacking (因為要找出所有可能，使用回溯法) 元素皆出現一次 Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; resultList = new ArrayList\u0026lt;\u0026gt;(); backtracking(resultList, new ArrayList\u0026lt;\u0026gt;(), nums); return resultList; } private void backtracking(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; resultList, ArrayList tempList, int[] nums) { if (tempList.size() == nums.length){ resultList.add(new ArrayList\u0026lt;\u0026gt;(tempList)); return; } for (int num : nums) { if (tempList.contains(num)) { continue; } tempList.add(num); backtracking(resultList, tempList, nums); tempList.remove(tempList.size() - 1); } } } ","date":"2023-11-27T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/algorithm-permutation-backtracking/","title":"Algorithm permutation \u0026 backtracking"},{"content":"two pointer \u0026amp; sliding window 系列 Two Pointer 常用於 Array, String, LinkedList\n左右指標 概念就是會去設定左右兩個指標，依照情況，移動其中的一個或兩個指標，兩個指標的方向可以是同方向，也可以是反向移動。\n快慢指標 Sliding window 概念就是可以使用一個 pointer 以及一個 window size 去實作，且會利用 window 中的 elements去依照情境去使用，就不用像 two pointer 兩個 pointer 去實作。\nTwo Pointer vs Sliding window 差異 :\ntwo pointer 操作雙指針 sliding window 主要操作 window 中的 elements LeetCode 練習 3. Longest Substring Without Repeating Characters Given a string s, find the length of the longest substring without repeating characters.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int lengthOfLongestSubstring(String s) { int longest = 0; Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0, j = 0; j \u0026lt; s.length(); j++) { if (map.containsKey(s.charAt(j))) { i = Math.max(map.get(s.charAt(j)), i); } longest = Math.max(longest, j - i + 1); map.put(s.charAt(j), j + 1); } return longest; } } 26. Remove Duplicates from Sorted Array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int i = 0; for (int j = 1; j \u0026lt; nums.length; j++) { if (nums[j] != nums[i]) { i++; nums[i] = nums[j]; } } return i + 1; } } 80. Remove Duplicates from Sorted Array II 解題想法:\n已排序(小到大) case 1: 沒有重複 case 2: 有重複且必須 \u0026lt; 2，只要小於2 處理方式幾乎就跟 case 1 一樣了 ! 指針 i 是為要插入的位置 指針 j 是單純遍歷 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int i = 0; int count = 1; for (int j = 1; j \u0026lt; nums.length; j++) { if (nums[j] != nums[i]) { i++; nums[i] = nums[j]; count = 1; } else { if ( count \u0026lt; 2) { i++; nums[i] = nums[j]; count++; } } } return i + 1; } } 大神的作法:\n解析:\n已排序 i 為要插入值的位置 使用 for-each 去遍歷陣列 i \u0026lt; 2 表示，如果要有重複值出現至少要大於2，題目限制重複2次可以，所以無論如何最初前兩個一定會被加到陣列中，簡而言之，前兩個一定會在我們最後答案的陣列中。 n \u0026gt; nums[i-2] 代表針對排除陣列最前面兩項後，來做排序，而因為由小到大，所以如果 n \u0026gt; nums[i-2] 代表，大於前面的數字，也代表沒出現過。 1 2 3 4 5 6 7 public int removeDuplicates(int[] nums) { int i = 0; for (int n : nums) if (i \u0026lt; 2 || n \u0026gt; nums[i-2]) nums[i++] = n; return i; } Note:\n1 nums[i++] = n; 等同\n1 2 nums[i] = n; i++; 977. Squares of a Sorted Array Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n給一個數組，平方，其中會有負數。\n解法一: 暴力法，先平方在比大小 解法二: two pointer，先絕對值比大小在平方和塞到新數組\n解法一 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int[] sortedSquares(int[] nums) { for (int i = 0; i \u0026lt; nums.length; i++) { int positive = Math.abs(nums[i]); nums[i] = (int) Math.pow(positive, 2); } Arrays.sort(nums); return nums; } } 平方操作：遍歷整個數組並對每個元素進行平方，其時間複雜度為O(n)， 其中 n 是數組 nums 的長度。\n排序操作：使用 Arrays.sort() 對數組進行排序，其平均時間複雜度為O(nlogn)。 綜合來看，解法一的總時間複雜度O(nlogn)，因為排序操作占主導。\n空間複雜度 這種方法直接在輸入數組 nums 上操作，並沒有使用額外的顯著空間（除了幾個基本變量外）。因此，其空間複雜度為O(1)。\n解法二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int[] sortedSquares(int[] nums) { int n = nums.length; int[] result = new int[n]; int left = 0, right = n - 1; for (int i = n - 1; i \u0026gt;= 0; i--) { if (Math.abs(nums[left]) \u0026gt; Math.abs(nums[right])) { result[i] = (int)Math.pow(nums[left],2); left++; } else { result[i] = (int)Math.pow(nums[right],2); right--; } } return result; } } 時間複雜度 雙指針操作：通過一次遍歷來填充結果數組 result。每個元素僅被訪問一次，因此時間複雜度為O(n)。 這種方法利用了原始數組的已排序特性，避免了額外的排序操作，因此總時間複雜度為O(n)。\n空間複雜度 這種方法使用了一個額外的數組 result 來存儲結果，這個數組與輸入數組 nums 大小相同。因此，其空間複雜度為 O(n)。\n結論 解法一的時間複雜度為 O(nlogn)，空間複雜度為O(1)。 解法二的時間複雜度為 O(n)，空間複雜度為O(n)。 因此，如果空間不是一個主要考慮因素，解法二在效率上更佳，尤其是在數組較大時。\n","date":"2023-11-27T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/algorithm-two-pointer-sliding-window/","title":"Algorithm two pointer \u0026 sliding window"},{"content":"HackerRank - Mini-Max Sum Given five positive integers, find the minimum and maximum values that can be calculated by summing exactly four of the five integers. Then print the respective minimum and maximum values as a single line of two space-separated long integers.\nExample arr = [1, 3, 5, 7, 9] The minimum sum is 1+3+5+7=16 and the maximum sum is 3+5+7+9=24 . The function prints\n1 16 24 My code 修正前 一開始的想法，沒考慮到array中有可能有負數的作法 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public static void miniMaxSum(List\u0026lt;Integer\u0026gt; arr) { // Write your code here List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); int sum = 0; int min = 0; for (int value : arr) { sum += value; } min = sum; int max = 0; for (int value : arr) { int sumWithoutValue = sum - value; if( sumWithoutValue \u0026gt; max) { max = sumWithoutValue; } if( sumWithoutValue \u0026lt; min) { min = sumWithoutValue; } } System.out.println(min + \u0026#34; \u0026#34; + max); } 新增一個總和變數\n先加總整個List\n給予兩個變數 min max\n先將總和賦值給變數 min 目的: 排除一個元素後的總和必定小於或等於所有元素的總和（因為所有元素都是正數）。因此，通過將 min 初始設置為 sum，我們可以確保在遍歷陣列時，任何比 sum 小的總和都會更新 min。\n接下來邏輯的部分就是 : 逐一排除元素後的總和 : sumWithoutValue\n如果 sumWithoutValue 大於 max，max 為 sumWithoutValue 如果 sumWithoutValue 小於 min，min 為 sumWithoutValue 修正後 考量溢出問題用 Long 負數問題 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import java.io.*; import java.math.*; import java.security.*; import java.text.*; import java.util.*; import java.util.concurrent.*; import java.util.function.*; import java.util.regex.*; import java.util.stream.*; import static java.util.stream.Collectors.joining; import static java.util.stream.Collectors.toList; class Result { /* * Complete the \u0026#39;miniMaxSum\u0026#39; function below. * * The function accepts INTEGER_ARRAY arr as parameter. */ public static void miniMaxSum(List\u0026lt;Integer\u0026gt; arr) { // Write your code here long totalSum = 0; long minSum = Long.MAX_VALUE; long maxSum = Long.MIN_VALUE; for (int value : arr) { totalSum += value; } for (int value : arr) { long sumWithoutValue = totalSum - value; minSum = Math.min(minSum, sumWithoutValue); maxSum = Math.max(maxSum, sumWithoutValue); } System.out.println(minSum + \u0026#34; \u0026#34; + maxSum); } } public class Solution { public static void main(String[] args) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); List\u0026lt;Integer\u0026gt; arr = Stream.of(bufferedReader.readLine().replaceAll(\u0026#34;\\\\s+$\u0026#34;, \u0026#34;\u0026#34;).split(\u0026#34; \u0026#34;)) .map(Integer::parseInt) .collect(toList()); Result.miniMaxSum(arr); bufferedReader.close(); } } ","date":"2023-11-27T00:00:00Z","image":"https://rickyhsieh.github.io/p/hackerrank-mini-max-sum/hk-cover1_hu468eb36026cd721fd2f3e4d5b434dfd0_220995_120x120_fill_q75_box_smart1.jpg","permalink":"https://rickyhsieh.github.io/p/hackerrank-mini-max-sum/","title":"HackerRank - Mini-Max Sum"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://rickyhsieh.github.io/p/image-gallery/2_hubce42636ecacc1a380b462f3110efcec_37455_120x120_fill_q75_box_smart1.jpg","permalink":"https://rickyhsieh.github.io/p/image-gallery/","title":"Image gallery"},{"content":"先建立多環境properties 在src/main/resources 目錄下新建兩個屬性檔案，分別為 application-dev.properties 和 application-prod.properties，前者適用於開發後者用於正式環境設定檔。\n這邊只是演示 (一般不設定Debug等級日誌是因為會有很多日誌資訊，增加起動專案名稱，影響開發效率):\n在 dev 環境下，日誌以 Debug 等級或更高等級為輸出到控制台，application-dev.properties :\n1 logging.level.root=DEBUG 在application-prod.properties則設定 :\n1 2 logging.file.name=f://logs//demo.log logging.level.root=WARN 注意事項 logging.file.name 用於指定日誌名稱(可以是精確位置)，也可以是相對於目前目錄的位置。 容易混淆的是 : logging.file.path (這是用來指定日誌的位置)\n這兩個屬性不能同時使用，如果同時，預設logging.file.name屬性生效。\n接下來在主設定檔application.properties :\n測試 這樣是吃 Dev log檔案設定會發生變化\n1 spring.profiles.active=dev 反之 這樣是吃 Prod\n1 spring.profiles.active=prod ","date":"2023-08-25T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/springboot-profile-%E4%BD%BF%E7%94%A8%E5%B1%AC%E6%80%A7%E6%AA%94%E6%A1%88%E8%A8%AD%E5%AE%9A%E5%A4%9A%E7%92%B0%E5%A2%83/","title":"SpringBoot Profile 使用屬性檔案設定多環境"},{"content":"SpringBoot 使用日誌元件 SpringBoot 預設使用的日誌元件 logback，由log4j創始人設計。\n如果要修改日誌的輸出格式，只需要在 src/main/resources目錄下建立名為 logback-spring.xml 或者 logback.xml 的檔案即可。\nSpringBoot 會自動讀取該檔案的設定檔，如果需要SpringBoot設定檔中，透過logging.config屬性給出自定義的檔案的名稱。\n","date":"2023-08-25T12:00:00Z","permalink":"https://rickyhsieh.github.io/p/springboot-%E8%A8%AD%E5%AE%9A%E6%97%A5%E8%AA%8C/","title":"SpringBoot 設定日誌"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://rickyhsieh.github.io/p/shortcodes/cover_huec3c3e34981507583e214021ad1b9a4b_12942_120x120_fill_q75_box_smart1.jpg","permalink":"https://rickyhsieh.github.io/p/shortcodes/","title":"Shortcodes"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi),e^{2 \\pi i \\xi x},d\\xi $$\n1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"what is static initialize ? Static Initialization Blocks\n作用：用於初始化類別變數（靜態變數），尤其是當初始化需要某一些邏輯（例如錯誤處理或迴圈）時。 定義：由靜態關鍵字 static 和花括號 {} 包圍的程式碼區塊。 可以有多個靜態初始化區塊，它們按照在類別中出現的順序執行。 例如：\n1 2 3 static { // 初始化程式碼 } private static initialze：作為靜態初始化區塊的替代方案，可以用於稍後重新初始化類別變數。\nHere is my code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.io.*; import java.util.*; public class Solution { static int breadth; static int height; static boolean flag; static { Scanner sc = new Scanner(System.in); breadth = sc.nextInt(); height = sc.nextInt(); if (breadth \u0026gt; 0 \u0026amp;\u0026amp; height \u0026gt; 0) { flag = true; } else { System.out.println(\u0026#34;java.lang.Exception: Breadth and height must be positive\u0026#34;); } } public static void main(String[] args) { if (flag) { long area = height * breadth; System.out.println(area); } } } ","date":"2022-03-06T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/hackerrank-java-static-initializer-block/","title":"HackerRank - Java Static Initializer Block"},{"content":"Activity 簡介 An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).\nsetContentView(R.layout.your_layout)\nActivity 文件\n用途 在Android開發中，Activity是一個非常核心的概念。一個Activity代表著一個單一的屏幕（UI），用戶可以在這個屏幕上與應用程序交互。每個Activity都提供了一個窗口來繪製其用戶界面。整個應用可以由多個Activity組成，每個Activity都是獨立的。\n以下是一些Activity的主要特點和功能：\n用戶界面的容器：Activity通常包含各種UI元素，如按鈕、文本框和圖片視圖等。\n生命周期管理：Android系統會根據應用的需要和系統資源的狀態，管理Activity的生命週期。Activity有多個生命週期回調方法，如onCreate(), onStart(), onPause(), onResume(), 和onDestroy()。\n交互和導航：Activity之間可以透過Intent進行交互。通過Intent，一個Activity可以啟動另一個Activity，並傳遞數據。\n狀態保存和恢復：當Activity因為系統配置更改（如旋轉屏幕）或者內存不足被系統銷毀時，它可以保存和恢復其狀態。\n資源管理：Activity可以加載不同的布局和資源，以適應不同的裝置和屏幕尺寸。\n權限管理：某些Activity可能需要請求特定權限，以訪問系統功能或資料（如攝像頭或聯繫人）。\n一個典型的Android應用通常至少包含一個Activity，即主Activity，它是用戶與應用互動的入口點。开发者可以根据应用的需求设计更复杂的Activity架构和导航流程。\n當我們新建avtivity時\n1 2 3 4 5 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } ","date":"0001-01-01T00:00:00Z","permalink":"https://rickyhsieh.github.io/p/android-development-activity/","title":"Android Development - Activity"}]